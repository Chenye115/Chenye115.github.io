<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Chapter 11 File System Implementation</title>
    <url>/2020/06/08/Chapter%2011%20File%20System%20Implementation/</url>
    <content><![CDATA[<h1 id="Chapter-11-File-System-Implementation"><a href="#Chapter-11-File-System-Implementation" class="headerlink" title="Chapter 11: File System Implementation"></a>Chapter 11: File System Implementation</h1><h2 id="File-System-Structure"><a href="#File-System-Structure" class="headerlink" title="File-System Structure"></a>File-System Structure</h2><p>File control block–storage structure consisting of information about a file. 文件控制块放在硬盘上，内存中存放的有文件控制块所包含的内容，文件存放在硬盘，硬盘上的存储是非易失的。</p>
<p>File structure: Logical storage unit  Collection of related information </p>
<p><strong>Layered File System：</strong></p>
<img src="/08/Chapter%2011%20File%20System%20Implementation/Users\kali_chenye\AppData\Roaming\Typora\typora-user-images\1591584216371.png" alt="1591584216371" style="zoom:50%;">

<p>应程程序进行系统调用：open read write… 执行IO语句</p>
<p>逻辑文件系统：目录 FCB 文件具体放在block（logic）上</p>
<p>文件组织模块：逻辑块映射到物理块 </p>
<p>基本文件系统：发出IO命令 磁盘地址</p>
<p>IO control：设备驱动</p>
<p>设备：以上都是软件层面，只有device是硬件  </p>
<p><strong>A Typical File Control Block</strong>: file permission, file dates, file owner,group,ACL ,file size ,file date blocks 抓住了文件控制块就抓住了文件</p>
<p>on-disk information: </p>
<p>boot control block,volume control block(每分区一个)  directory structure(每个文件系统一个)</p>
<p>FCB i-node UFS (这些信息放在磁盘上，文件加载后有些信息会放在内存中)</p>
<p><strong>In-Memory File System Structures</strong>：</p>
<p><img src="/08/Chapter%2011%20File%20System%20Implementation/C:%5CUsers%5Ckali_chenye%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1591585104441.png" alt="1591585104441"></p>
<p><img src="/08/Chapter%2011%20File%20System%20Implementation/C:%5CUsers%5Ckali_chenye%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1591585142146.png" alt="1591585142146"></p>
<a id="more"></a>

<h2 id="Directory-Implementation"><a href="#Directory-Implementation" class="headerlink" title="Directory Implementation"></a>Directory Implementation</h2><ul>
<li>Linear list of file names with pointer to the data blocks ：</li>
</ul>
<p>simple to program </p>
<p>time-consuming to execute</p>
<ul>
<li>Hash Table –linear list with hash data structure ：</li>
</ul>
<p>decreases directory search time </p>
<p>collisions –situations where two file names hash to the same location</p>
<img src="/08/Chapter%2011%20File%20System%20Implementation/Users\kali_chenye\AppData\Roaming\Typora\typora-user-images\1591585420213.png" alt="1591585420213" style="zoom:67%;">

<h2 id="Allocation-Methods"><a href="#Allocation-Methods" class="headerlink" title="Allocation Methods"></a>Allocation Methods</h2><h3 id="Contiguous-Allocation"><a href="#Contiguous-Allocation" class="headerlink" title="Contiguous Allocation"></a>Contiguous Allocation</h3><ul>
<li>Each file occupies a set of contiguous blocks on the disk.</li>
<li>Simple –only starting location (block #) and length (number of blocks) are required.</li>
<li>Random access.</li>
<li>Wasteful of space 外部碎片</li>
<li>Files cannot grow</li>
</ul>
<img src="/08/Chapter%2011%20File%20System%20Implementation/Users\kali_chenye\AppData\Roaming\Typora\typora-user-images\1591585602845.png" alt="1591585602845" style="zoom:50%;">

<h3 id="Extent-Based-Systems"><a href="#Extent-Based-Systems" class="headerlink" title="Extent-Based Systems"></a>Extent-Based Systems</h3><p>Extent-based file systems allocate disk blocks in <strong>extents.</strong> </p>
<p>An extent is a contiguous block of disks. Extents are allocated for file allocation. A file consists of one or more extents。 类似于存储管理中的分段segement</p>
<h3 id="Linked-Allocation"><a href="#Linked-Allocation" class="headerlink" title="Linked Allocation"></a>Linked Allocation</h3><p>Each file is a linked list of disk blocks: blocks may be scattered anywhere on the disk.</p>
<ul>
<li>Simple –need only starting address </li>
<li>Free-space management system –no waste of space </li>
<li>Files can grow </li>
<li>No random access </li>
<li>Each block contains a pointer, wasting space </li>
<li>Blocks scatter everywhere and a large number of disk seeks may be necessary </li>
<li>Reliability: what if a pointer is lost or damaged 不安全不可靠</li>
</ul>
<h3 id="File-Allocation-Table-FAT"><a href="#File-Allocation-Table-FAT" class="headerlink" title="File-Allocation Table FAT"></a>File-Allocation Table FAT</h3><p>FAT表在磁盘的最开始</p>
<img src="/08/Chapter%2011%20File%20System%20Implementation/Users\kali_chenye\AppData\Roaming\Typora\typora-user-images\1591586295483.png" alt="1591586295483" style="zoom:50%;">

<p>实现了随机访问，更加安全可靠</p>
<h3 id="Indexed-Allocation"><a href="#Indexed-Allocation" class="headerlink" title="Indexed Allocation"></a>Indexed Allocation</h3><p>Brings all pointers together into the index block</p>
<p>A file’s directory entry contains a pointer to its index. Hence, the index block of an indexed allocation plays the same role as the page table.</p>
<img src="/08/Chapter%2011%20File%20System%20Implementation/Users\kali_chenye\AppData\Roaming\Typora\typora-user-images\1591586502853.png" alt="1591586502853" style="zoom:50%;">

<ul>
<li>*<em>Random access *</em></li>
<li>无外部碎片</li>
<li>不是安全可靠的</li>
<li>文件的grow是有限的</li>
</ul>
<p>The indexed allocation suffers from wasted space. The index block may not be fully used </p>
<p>The number of entries of an index table determines the size of a file. To overcome this problem, we can have ：</p>
<ul>
<li>multiple index blocks, chain them into a linked-list </li>
<li>multiple index blocks, but make them a tree just like the indexed access method </li>
<li>A combination of both</li>
</ul>
<img src="/08/Chapter%2011%20File%20System%20Implementation/Users\kali_chenye\AppData\Roaming\Typora\typora-user-images\1591586700043.png" alt="1591586700043" style="zoom:50%;">

<p><img src="/08/Chapter%2011%20File%20System%20Implementation/C:%5CUsers%5Ckali_chenye%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1591587524372.png" alt="1591587524372"></p>
<p><img src="/08/Chapter%2011%20File%20System%20Implementation/C:%5CUsers%5Ckali_chenye%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1591587687829.png" alt="1591587687829"></p>
<p>4 128 84+2^16</p>
<h2 id="Free-Space-Management"><a href="#Free-Space-Management" class="headerlink" title="Free-Space Management"></a>Free-Space Management</h2><p>How do we keep track free blocks on a disk?  A free-list is maintained(维护).</p>
<p>When a new block is requested, we search this list to find one. </p>
<ul>
<li>Bit Vector </li>
<li>Linked List </li>
<li>Linked List + Grouping </li>
<li>Linked List+Address+Count</li>
</ul>
<p><strong>Linked Free Space List on Disk</strong>:</p>
<img src="/08/Chapter%2011%20File%20System%20Implementation/Users\kali_chenye\AppData\Roaming\Typora\typora-user-images\1591588592801.png" alt="1591588592801" style="zoom:50%;">

<p><strong>Link+Grouping:</strong></p>
<p>The first free block contains the addresses of n other free blocks. </p>
<p>For each group, the first n-1 blocks are actually free and the last (i.e., n-th) block contains the addresses of the next group. </p>
<p><strong>Link+Address counting:</strong></p>
<p>Blocks are often allocated and freed in groups</p>
<p>We can store the address of the first free block and the number of the following n free blocks.</p>
<h2 id="Efficiency-and-Performance"><a href="#Efficiency-and-Performance" class="headerlink" title="Efficiency and Performance"></a>Efficiency and Performance</h2><p>Efficiency dependent on: </p>
<ul>
<li>disk allocation and directory algorithms </li>
<li>types of data kept in file’s directory entry </li>
</ul>
<p>Performance:</p>
<ul>
<li>disk cache </li>
<li>free-behind and read-ahead  延后释放，提前读取</li>
<li>improve PC performance by dedicating section of memory as virtual disk, or RAM disk 提升硬件性能</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Chapter 8  Memory Management</title>
    <url>/2020/05/31/Chapter%208%20%20Memory%20Management/</url>
    <content><![CDATA[<h1 id="Chapter-8-Memory-Management"><a href="#Chapter-8-Memory-Management" class="headerlink" title="Chapter 8:  Memory Management"></a>Chapter 8:  Memory Management</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Program must be brought into memory and placed within a process for it to be run</p>
<h3 id="Base-and-Limit-Registers"><a href="#Base-and-Limit-Registers" class="headerlink" title="Base and Limit Registers"></a>Base and Limit Registers</h3><p>A pair of base and limit registers define the logical address space</p>
<h3 id="Multi-step-Processing-of-a-User-Program"><a href="#Multi-step-Processing-of-a-User-Program" class="headerlink" title="Multi-step Processing of a User Program"></a>Multi-step Processing of a User Program</h3><p><img src="/31/Chapter%208%20%20Memory%20Management/C:%5CUsers%5Ckali_chenye%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1589504830233.png" alt="1589504830233"></p>
<h3 id="Binding-of-Instructions-and-Data-to-Memory"><a href="#Binding-of-Instructions-and-Data-to-Memory" class="headerlink" title="Binding of Instructions and Data to Memory"></a>Binding of Instructions and Data to Memory</h3><p>Address binding of instructions and data to memory addresses can happen at three different stages</p>
<p><strong>Compile time</strong>:  If memory location known a priori, absolute code can be generated; must recompile code if starting location changes. </p>
<p><strong>Load time:</strong>  Must generate relocatable code if memory location is not known at compile time. </p>
<p><strong>Execution time</strong>:  Binding delayed until run time if the process can be moved during its execution from one memory segment to another.  Need hardware support for address maps</p>
<a id="more"></a>

<h3 id="Logical-vs-Physical-Address-Space"><a href="#Logical-vs-Physical-Address-Space" class="headerlink" title="Logical vs. Physical Address Space"></a>Logical vs. Physical Address Space</h3><ul>
<li><p>Logical address–generated by the CPU; also referred to as virtual address. </p>
</li>
<li><p>Physical address–address seen by the memory unit.</p>
</li>
</ul>
<p>Logical and physical addresses are the same in compile-time and load-time address-binding schemes </p>
<p>logical and physical addresses differ in execution time address-binding scheme</p>
<p>In this case, logical address is also referred to as virtual address. (Logical = Virtual in this course) MMU内存管理单元来决定虚拟地址到物理地址的转换 <strong>Memory-Management Unit</strong> </p>
<p>The user program deals with logical addresses; it never sees the real physical addresses.</p>
<h3 id="Dynamic-Loading"><a href="#Dynamic-Loading" class="headerlink" title="Dynamic Loading"></a>Dynamic Loading</h3><p>Better memory-space utilization; unused routine is never loaded</p>
<p>Useful when large amounts of code are needed to handle infrequently occurring cases</p>
<h3 id="Dynamic-Linking"><a href="#Dynamic-Linking" class="headerlink" title="Dynamic Linking"></a>Dynamic Linking</h3><p>比动态load更进一步 Both Linking and loading postponed until execution time. </p>
<p><strong>节省内存，灵活性</strong></p>
<p>When a routine is called, its stub is executed. The routine is loaded, the address of that routine replaces the stub, and executes the routine</p>
<p>Operating system needed to check <strong>if routine is in another process’ memory address</strong></p>
<p>Dynamic linking is particularly useful for libraries</p>
<h2 id="Swapping"><a href="#Swapping" class="headerlink" title="Swapping"></a>Swapping</h2><h2 id="Contiguous-Allocation"><a href="#Contiguous-Allocation" class="headerlink" title="Contiguous Allocation"></a>Contiguous Allocation</h2><p>如何分配给不同的进程使用 如何找到进程要访问的内存地址（寻址）</p>
<p><strong>Monoprogramming systems</strong> ：</p>
<ul>
<li>系统</li>
<li>用户</li>
</ul>
<p><strong>Multiprogramming systems：</strong></p>
<ul>
<li>Fixed partitions </li>
<li>variable partitions</li>
</ul>
<p><strong>Fixed partitions</strong>：</p>
<p>Memory is divided into n partitions. Partitioning can be done at the startup time and altered later on. <strong>Each partition may have a job queue. Or, all partitions share the same job queue</strong></p>
<p><img src="/31/Chapter%208%20%20Memory%20Management/C:%5CUsers%5Ckali_chenye%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1589508667796.png" alt="1589508667796"></p>
<p><strong>Variable Partitions ：</strong></p>
<p><strong><em>Hole</em></strong>–block of available memory–&gt;How to satisfy a request of size n from a list of free holes</p>
<ul>
<li>First-fit(首次适配)</li>
<li>Best-fit(最佳适配)</li>
<li>Worst-fit(最差适配)</li>
</ul>
<h4 id="Fragmentation-碎片"><a href="#Fragmentation-碎片" class="headerlink" title="Fragmentation(碎片)"></a>Fragmentation(碎片)</h4><p>Free memory holes between allocated ones are called <strong>external fragmentation</strong>外部碎片</p>
<p> memory that is allocated to a partition, but is not used, are called <strong>internal fragmentation</strong>内部碎片</p>
<p>外部碎片不可避免</p>
<h4 id="Compaction-for-External-Fragmentation"><a href="#Compaction-for-External-Fragmentation" class="headerlink" title="Compaction for External Fragmentation"></a>Compaction for External Fragmentation</h4><p>Compaction is possible <strong>only</strong> if relocation is dynamic, and is done at execution time</p>
<p>compaction scheme can be expensive</p>
<p><img src="/31/Chapter%208%20%20Memory%20Management/C:%5CUsers%5Ckali_chenye%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1589510716937.png" alt="1589510716937"></p>
<p>AC 连续分配容易通过base和limit寄存器实现内存保护</p>
<h2 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h2><p>不连续分配的一种方法</p>
<p> Divide physical memory into fixed-sized blocks called <strong>frames(帧)</strong></p>
<p> Divide logical memory into blocks of same size called <strong>pages(页)</strong></p>
<ul>
<li>Keep track of all free frames. </li>
<li>To run a program of size n pages, need to find n free frames and load program. </li>
<li>Set up a page table to translate logical to physical addresses. </li>
<li>Internal fragmentation.</li>
</ul>
<p>平均Internal fragmentation的大小是半个frame/page</p>
<h3 id="Address-Translation-Scheme"><a href="#Address-Translation-Scheme" class="headerlink" title="Address Translation Scheme"></a>Address Translation Scheme</h3><p>Address generated by CPU is divided into:</p>
<ul>
<li>Page number(p)</li>
<li>Page offset (d)</li>
</ul>
<p><img src="/31/Chapter%208%20%20Memory%20Management/C:%5CUsers%5Ckali_chenye%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1589510062828.png" alt="1589510062828"></p>
<p>logical–&gt; pages</p>
<p>physical–&gt;frames</p>
<h3 id="Implementation-of-Page-Table"><a href="#Implementation-of-Page-Table" class="headerlink" title="Implementation of Page Table"></a>Implementation of Page Table</h3><ul>
<li>Page table is kept in main memory.</li>
<li><strong>Page-table base register (PTBR)</strong>points to the page table</li>
</ul>
<p>TLB 快表: Hit ratio = α</p>
<p>Effective Access Time (EAT)</p>
<p>​     EAT = (1 + ε) α+ (2 + ε）(1 –α) = 2 + ε- α</p>
<h4 id="Memory-Protection"><a href="#Memory-Protection" class="headerlink" title="Memory Protection"></a>Memory Protection</h4><p>Memory protection implemented by associating protection bit with each frame</p>
<p><strong>Valid-invalid bit</strong>:</p>
<ul>
<li><p><strong>valid</strong></p>
</li>
<li><p><strong>invalid</strong>: the page is not in the process’ logical address space</p>
<p>we can use a <strong>page table length register (PTLR)</strong> that stores the length of a process’s page table.–&gt;a process cannot access the memory beyond its region</p>
</li>
</ul>
<h3 id="Page-Table-Structure"><a href="#Page-Table-Structure" class="headerlink" title="Page Table Structure"></a>Page Table Structure</h3><p>Hierarchical Page Tables 分级页表：</p>
<p>Break up the logical address space into multiple page tables</p>
<p><img src="/31/Chapter%208%20%20Memory%20Management/C:%5CUsers%5Ckali_chenye%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1589514600311.png" alt="1589514600311"></p>
<p><strong><em>Answer： 8 7 9</em></strong></p>
<p>Hashed Page Tables</p>
<p>Inverted Page Table</p>
]]></content>
  </entry>
  <entry>
    <title>Chapter 5 Thread</title>
    <url>/2020/04/09/Chapter%205%20Thread/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qq_43721475/article/details/104834649" target="_blank" rel="noopener">OS Review Chapter 1: Introduction</a><br><a href="https://blog.csdn.net/qq_43721475/article/details/104836492" target="_blank" rel="noopener">OS Review Chapter 2: Computer-System Structures</a><br><a href="https://blog.csdn.net/qq_43721475/article/details/104846186" target="_blank" rel="noopener">OS Review Chapter 3: Operating-System Structures</a><br><a href="https://blog.csdn.net/qq_43721475/article/details/105397752" target="_blank" rel="noopener">OS Review Chapter 4: Process</a><br><a href="https://blog.csdn.net/qq_43721475/article/details/105404697" target="_blank" rel="noopener">OS Review Chapter 5: Thread</a></p>
<h1 id="Chapter-5-Thread"><a href="#Chapter-5-Thread" class="headerlink" title="Chapter 5 Thread"></a>Chapter 5 Thread</h1><p>What is a thread?–A thread, also known as lightweight process (LWP),<strong>is a basic unit of CPU execution.</strong></p>
<p>A thread has a thread ID, a program counter, a register set, and a stack–similar to a process</p>
<p>*<em>However, a thread shares with other threads in the same process its code section, data section, and other OS resources (e.g., files and signals). *</em></p>
<p><img src="../images/c51.png" alt="1586356695921"></p>
<p>同一个进程的多个线程共享该进程的其他资源（不包括CPU、寄存器、栈）</p>
<p>Linux中不存在线程进程的概念，同一称作task</p>
<p><code>图片无法加载请跳转至csdn</code></p>
<a id="more"></a>

<h2 id="Thread-Usage"><a href="#Thread-Usage" class="headerlink" title="Thread Usage"></a>Thread Usage</h2><p><img src="../images//c52.png" alt="1586357091134"></p>
<h2 id="Benefits"><a href="#Benefits" class="headerlink" title="Benefits"></a>Benefits</h2><ul>
<li>Responsiveness</li>
<li>Resource Sharing (进程之间资源共享需要调用系统调用，需要频繁切换到kernel)</li>
<li>Economy (创建时的开销)</li>
<li>Utilization of MP(multi processors) Architectures</li>
</ul>
<h2 id="User-Threads"><a href="#User-Threads" class="headerlink" title="User Threads"></a>User Threads</h2><p>Thread management done by user-level threads library  –POSIX Pthreads </p>
<p>用户线程阻塞会导致该进程的其他线程阻塞，kernel不知道process中的其他thread，认为这个process是阻塞的。 if one thread is blocked, every other threads of the same process are also blocked because the containing process is blocked.</p>
<p>User threads are supported at the user level. The kernel is not aware of user threads. </p>
<p>A library provides all support for thread creation, termination, joining, and scheduling. There is no kernel intervention, and, hence, user threads are usually more efficient. </p>
<p><img src="../images//c53.png" alt="1586358017933"></p>
<h2 id="Kernel-Threads"><a href="#Kernel-Threads" class="headerlink" title="Kernel Threads"></a>Kernel Threads</h2><p>Kernel threads are directly supported by the kernel. The kernel does thread creation,termination, joining, and scheduling in kernel space. </p>
<p>Kernel threads are usually slower than the user threads.</p>
<p>通常是用户创建一个kernel thread，导致kernel需要进行系统调用陷入内核，创建完成后返回用户态</p>
<p>However, blocking one thread will not cause other threads of the same process to block. The kernel simply runs other threads. </p>
<p><strong>In a multiprocessor environment, the kernel can schedule threads on different processors</strong></p>
<h2 id="Multithreading-Models"><a href="#Multithreading-Models" class="headerlink" title="Multithreading Models"></a>Multithreading Models</h2><h3 id="Many-to-One"><a href="#Many-to-One" class="headerlink" title="Many-to-One"></a>Many-to-One</h3><p> 多对一模型：多个用户级线程线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。<br>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。<br>缺点：当一个用户线程阻塞后，整个进程就会都阻塞，并发度不高。多个线程不可在多处理机上并行运行。 </p>
<h3 id="One-to-One"><a href="#One-to-One" class="headerlink" title="One-to-One"></a>One-to-One</h3><p> 一个用户进程对应一个内核进程。每个用户有与内核进程相同数量的用户进程。<br>优点：当一个线程被阻塞后，另外的线程还可以继续执行，并发性强。多线程可在多核处理机上并发执行<br>缺点：一个用户线程会占用多个内核级线程，线程切换是需要将用户态转换为核心态，因此线程管理的成本高，开销大。 </p>
<h3 id="Many-to-Many"><a href="#Many-to-Many" class="headerlink" title="Many-to-Many"></a>Many-to-Many</h3><p>Allows many user level threads to be mapped to many kernel threads. Allows the  operating system to create a sufficient number of kernel threads. </p>
<p> 多对多模型：n个用户级线程映射到m个内核级线程（n&gt;=m）。每个用户进程对应m个内核级线程。<br>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。 </p>
<h2 id="Threading-Issues"><a href="#Threading-Issues" class="headerlink" title="Threading Issues"></a>Threading Issues</h2><p>Semantics of fork() and exec() system calls. ？？？</p>
<h3 id="Thread-cancellation"><a href="#Thread-cancellation" class="headerlink" title="Thread cancellation."></a>Thread cancellation.</h3><ul>
<li><strong>Asynchronous cancellation</strong> terminates the target thread  immediately （实现过程简单）</li>
<li><strong>Deferred cancellation *<em>allows the target thread to periodically check if it should be cancelled ：The point a thread can terminate itself is a *</em>cancellation point</strong>（延迟，安全撤销）</li>
</ul>
<p>Pthread supports deferred cancellation.</p>
<p>With asynchronous cancellation, if the target thread owns some system-wide resources, the system may not be able to reclaim all recourses. </p>
<p>But for deferred cancellation,Reclaiming resources is not a problem.</p>
<h2 id="Signal-Handling"><a href="#Signal-Handling" class="headerlink" title="Signal Handling"></a>Signal Handling</h2><h2 id="Thread-Pools"><a href="#Thread-Pools" class="headerlink" title="Thread Pools"></a>Thread Pools</h2><p>Create a number of threads in a pool where they await work .</p>
<p>通常线程池中的线程数目是adaptive（自适应的）</p>
<p>Advantages: </p>
<p>◆Usually slightly faster to service a request with an existing thread than create a new thread </p>
<p>◆Allows the number of threads in the application(s) to be bound to the size of the pool</p>
<h3 id="Solaris-2-Threads"><a href="#Solaris-2-Threads" class="headerlink" title="Solaris 2 Threads"></a>Solaris 2 Threads</h3><p>M:M</p>
<p><img src="../images//c54.png" alt="1586396393345"></p>
<h2 id="Windows-XP-Threads"><a href="#Windows-XP-Threads" class="headerlink" title="Windows XP Threads"></a>Windows XP Threads</h2><p>Implements the one-to-one mapping. </p>
<p>Each thread contains</p>
<ul>
<li>a thread id -</li>
<li>register set </li>
<li>separate user and kernel stacks </li>
<li>private data storage area</li>
</ul>
<p><img src="../images//c55.png" alt="1586397994132"></p>
<p>TEB: Thread Enviroment Block</p>
<h2 id="Linux-Threads"><a href="#Linux-Threads" class="headerlink" title="Linux Threads"></a>Linux Threads</h2><p>linux中的进程已经十分高效，引入线程作为资源共享的一个手段</p>
<p>Linux refers to them as tasks rather than threads.</p>
<p>Thread creation is done through clone() system call. Clone() allows a child task to share the address space of the parent task (process)</p>
<h2 id="Windows-Thread-APIs"><a href="#Windows-Thread-APIs" class="headerlink" title="Windows Thread APIs"></a>Windows Thread APIs</h2><ul>
<li>CreateThread </li>
<li>GetCurrentThreadId - returns global ID </li>
<li>GetCurrentThread - returns handle </li>
<li>SuspendThread/ResumeThread </li>
<li>ExitThread </li>
<li>TerminateThread </li>
<li>GetExitCodeThread </li>
<li>GetThreadTimes</li>
</ul>
<p>Example：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;synchapi.h&gt;</span></span></span><br><span class="line">BOOL thrdDone = FALSE;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">Fibonacci</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = a+b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i+<span class="number">1</span>&lt;&lt;<span class="string">" : "</span>&lt;&lt;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = n;</span><br><span class="line">        n = a + n;</span><br><span class="line">    &#125;</span><br><span class="line">    thrdDone = TRUE;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"enter the number of the Fibonacci:  "</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    HANDLE hThread;</span><br><span class="line">    hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)Fibonacci, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line">    <span class="keyword">while</span> (!thrdDone);</span><br><span class="line">    DWORD dw=WaitForSingleObject( hThread, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; dw;</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; "Hello World!\n";</span></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Example Explained: Main thread is process When process goes, all threads go Need some methods of waiting for a thread to finish</p>
<h3 id="Threads-states"><a href="#Threads-states" class="headerlink" title="Threads states"></a>Threads states</h3><p>pthread threads have two states</p>
<p> ◆joinable and detached </p>
<p>threads are joinable by default </p>
<p>◆Resources are kept until pthread_join </p>
<p>◆can be reset with attribute or API call </p>
<p>detached thread can not be joined </p>
<p>◆resources can be reclaimed at termination </p>
<p>◆cannot reset to be joinable</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SEQUENCE 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一组数据，用于创建线程时作为参数传入</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">     <span class="keyword">int</span> num; <span class="comment">//斐波那契数列的项数</span></span><br><span class="line">     <span class="keyword">int</span> Fibo[MAX_SEQUENCE];<span class="comment">//最大容量，斐波那契数列</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Fibonacci</span><span class="params">(<span class="keyword">void</span> *data)</span></span>&#123;<span class="comment">//获得斐波那契数列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> *<span class="title">tmp</span> = (<span class="title">struct</span> <span class="title">Data</span>*)<span class="title">data</span>;</span><span class="comment">//转化为实际类型</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(  tmp-&gt;num == <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error!enter a number larger than 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( tmp-&gt;num == <span class="number">1</span> )&#123;</span><br><span class="line">        tmp-&gt;Fibo[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp-&gt;Fibo[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    tmp-&gt;Fibo[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">2</span>; i &lt; tmp-&gt;num; i++ )&#123;</span><br><span class="line">        tmp-&gt;Fibo[i] = tmp-&gt;Fibo[i<span class="number">-1</span>] + tmp-&gt;Fibo[i<span class="number">-2</span>]; </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> th;<span class="comment">//线程标识符</span></span><br><span class="line">    <span class="keyword">int</span> ret; <span class="comment">//pthread的返回值 ret = 0,创建线程成功</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The fibonacci produce programe!\nPlease input an number within 1~200: "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span> || n &gt; <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Your input is error."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    data.num = n;<span class="comment">//赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//create a thread</span></span><br><span class="line">    ret = pthread_create(&amp;th, <span class="literal">NULL</span>, Fibonacci, (<span class="keyword">void</span> *)&amp;data);</span><br><span class="line">    <span class="keyword">if</span>( ret != <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Create thread error!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞调用线程</span></span><br><span class="line">    pthread_join( th, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出斐波那契数列</span></span><br><span class="line">    <span class="keyword">if</span>( data.num == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Nothing output."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The Fibonacci items are:  "</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,data.Fibo[i]);</span><br><span class="line">	    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/qq_43721475/article/details/104834649" target="_blank" rel="noopener">OS Review Chapter 1: Introduction</a><br><a href="https://blog.csdn.net/qq_43721475/article/details/104836492" target="_blank" rel="noopener">OS Review Chapter 2: Computer-System Structures</a><br><a href="https://blog.csdn.net/qq_43721475/article/details/104846186" target="_blank" rel="noopener">OS Review Chapter 3: Operating-System Structures</a><br><a href="https://blog.csdn.net/qq_43721475/article/details/105397752" target="_blank" rel="noopener">OS Review Chapter 4: Process</a><br><a href="https://blog.csdn.net/qq_43721475/article/details/105404697" target="_blank" rel="noopener">OS Review Chapter 5: Thread</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java多线程</title>
    <url>/2020/03/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>方法间的调用：普通方法的调用，从哪来到哪里去，闭合的一条路径</li>
<li>多线程的使用：开辟了多条路径</li>
</ul>
<h3 id="程序、进程与线程"><a href="#程序、进程与线程" class="headerlink" title="程序、进程与线程"></a>程序、进程与线程</h3><p>在操作系统中运行的程序就是进程，如看视频，一个进程（Process）可以有多个线程（Thread），如视频中同时听声音，看图像，显示字幕等等</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NzA1MTcyMA==&mid=403498894&idx=2&sn=219c1a6001b5bb7e6bdc7963b1af8450&scene=2&srcid=0330UDNmQ" target="_blank" rel="noopener">很有意思的关于线程的理解</a></p>
<ol>
<li><p>进程是资源管理的最小单位，线程是程序执行的最小单位。</p>
</li>
<li><p>每个进程都有自己的数据段、代码段和堆栈段。线程是轻量级的进程，它包含独立的栈和CPU寄存器状态，线程是进程的一条执行路径，每个线程共享其所附属进程的所有资源，包括打开的文件、内存页面、信号标识以及动态分配的内存等。</p>
</li>
<li><p>因为线程和进程比起来很小，所以相对来说，线程花费更少的CPU资源。</p>
</li>
<li><p>在操作系统设计上，从进程演化出线程，最主要的目的就是更好的支持多处理器，并且减少进程上下文切换的开销。</p>
</li>
<li><p>线程和进程的关系：线程是属于进程的，线程运行在进程空间内，同一进程所产生的的线程共享同一用户内存空间，当进程退出时该进程所产生的线程都会被强制退出并清除。所以，线程不能独立地执行，它必须依附在一个运行的应用程序上（即进程上），而一个进程至少需要一个线程作为它的指令执行，进程管理着资源（比如CPU、内存、文件等等）。而将线程分配到某个CPU上执行。</p>
</li>
</ol>
<p>线程和进程的区别：</p>
<p><img src="../images/5.jpg" alt></p>
<a id="more"></a>

<p>当操作系统分配给进程资源后，同属一个进程的多个线程之间可以相互共享进程中的内存资源，原因是线程没有自己独立的内存资源，它只有自己执行的堆栈和局部变量。而多个进程之间每个进程都拥有自己的一整套变量，即每个进程都有自己独立的内存单元。这就使得多线程之间的通信比多进程之间的通信更加的容易和高效。</p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
<li>实现Callable接口</li>
</ul>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程方式一</span></span><br><span class="line"><span class="comment"> * 继承Thread，重写run方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 线程入口点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"listening to music "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//super.run();</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;StartThread&gt; <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//启动线程 调用子类对象</span></span><br><span class="line">		<span class="comment">//创建子类对象</span></span><br><span class="line">		TestThread st=<span class="keyword">new</span> TestThread();</span><br><span class="line">		<span class="comment">//启动多线程</span></span><br><span class="line">		st.start();<span class="comment">//不保证立即调用，由CPU决定调用,等待调度</span></span><br><span class="line">		<span class="comment">//st.run();//普通方法的调用，没有开启多线程</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"while coding "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程方式二</span></span><br><span class="line"><span class="comment"> * 创建：实现runnable+重写run</span></span><br><span class="line"><span class="comment"> * 启动：创建实现类对象+thread对象+start</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 线程入口点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"listening to music "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//super.run();</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;StartThread&gt; <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//启动线程  创建实现类对象</span></span><br><span class="line">		StartRun st=<span class="keyword">new</span> StartRun();</span><br><span class="line">		<span class="comment">//创建代理类对象</span></span><br><span class="line">		Thread t=<span class="keyword">new</span> Thread(st);</span><br><span class="line">		<span class="comment">//启动多线程</span></span><br><span class="line">		t.start();</span><br><span class="line">		<span class="comment">//st.run();//普通方法的调用，没有开启多线程</span></span><br><span class="line">		<span class="comment">/**代码匿名，如果一个对象只使用一次</span></span><br><span class="line"><span class="comment">		new Thread(new StartRun()).start();</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"while coding "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>推荐使用这种方法，避免了单继承的局限性，OOP多实现，灵活方便，方便统一份对象的代理</em></strong></p>
<p>模拟12306抢票的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 共享资源,并发</span></span><br><span class="line"><span class="comment"> * 需要保证线程安全</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Web12306</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticketNums=<span class="number">99</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(ticketNums&lt;<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;"</span>+ticketNums--);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对同一个资源进行多个代理</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//一份资源</span></span><br><span class="line">		Web12306 web=<span class="keyword">new</span> Web12306();</span><br><span class="line">		<span class="comment">//多个代理</span></span><br><span class="line">		<span class="keyword">new</span> Thread(web,<span class="string">"1"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(web,<span class="string">"2"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(web,<span class="string">"3"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟龟兔赛跑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟龟兔赛跑</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Racer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String winner;<span class="comment">//胜利者</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">1</span>;step&lt;=<span class="number">100</span>;step++) &#123;</span><br><span class="line">			<span class="comment">//模拟休息,设置延时</span></span><br><span class="line">			<span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">"兔子"</span>)&amp;&amp;step%<span class="number">10</span>==<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">100</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;"</span>+step);</span><br><span class="line">			<span class="comment">//判断比赛是否结束</span></span><br><span class="line">	</span><br><span class="line">			<span class="keyword">boolean</span> flag=gameOver(step);</span><br><span class="line">			<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">gameOver</span><span class="params">(<span class="keyword">int</span> steps)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(winner!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(steps==<span class="number">100</span>) &#123;</span><br><span class="line">				winner=Thread.currentThread().getName();</span><br><span class="line">				System.out.println(<span class="string">"winner==&gt;"</span>+winner);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Racer racer=<span class="keyword">new</span> Racer();</span><br><span class="line">		<span class="keyword">new</span> Thread(racer,<span class="string">"乌龟"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(racer,<span class="string">"兔子"</span>).start();</span><br><span class="line">		<span class="comment">//racer.gameOver(100);</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><p>了解，并发变成JUC  重写call方法</p>
<h2 id="静态代理设计模式"><a href="#静态代理设计模式" class="headerlink" title="静态代理设计模式"></a>静态代理设计模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态代理</span></span><br><span class="line"><span class="comment"> * 公共接口：</span></span><br><span class="line"><span class="comment"> * 1.真实角色</span></span><br><span class="line"><span class="comment"> * 2.代理角色</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> WeddingCompany(<span class="keyword">new</span> You()).happyMarry();</span><br><span class="line">		<span class="comment">//new Thread(线程对象).start();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">happyMarry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"you get in love with her!!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeddingCompany</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Marry targe;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WeddingCompany</span><span class="params">(Marry target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.targe=target;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		ready();</span><br><span class="line">		<span class="keyword">this</span>.targe.happyMarry();</span><br><span class="line">		after();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"准备"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"清理"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="lambda推导-简化线程"><a href="#lambda推导-简化线程" class="headerlink" title="lambda推导 简化线程"></a>lambda推导 简化线程</h2><ul>
<li>避免匿名内部类定义过多</li>
<li>实质属于函数式编程的概念</li>
</ul>
<p>lambda表达式即将正式取代Java代码中的匿名内部类。匿名类的 this 关键字指向匿名类，而lambda表达式的 this 关键字指向包围lambda表达式的类。</p>
<p>java8中Lambda表达式的书写方式：<br>(参数) -&gt; 表达式<br>(参数) -&gt; 语句<br>(参数) -&gt; { 语句 }<br>例如，如果你的方法只是在控制台打印信息，则可以这么写：<br>() -&gt; System.out.println(“Hello Lambda Expressions”);</p>
<p>如果你的方法接收两个参数，那么：<br>(int even, int odd) -&gt; even + odd<br>原文链接：<a href="https://blog.csdn.net/iteye_3843/article/details/82570449" target="_blank" rel="noopener">https://blog.csdn.net/iteye_3843/article/details/82570449</a></p>
<p>*<em>以下是lambda的推导过程 *</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * lambda推导的过程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 陈烨</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">	<span class="comment">//静态内部类</span></span><br><span class="line">	 <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Like2</span> <span class="keyword">implements</span> <span class="title">ILike</span></span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			System.out.println(<span class="string">"i like lambda2"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ILike like = <span class="keyword">new</span> Like();</span><br><span class="line">		like.lambda();</span><br><span class="line">		like = <span class="keyword">new</span> Like2(); </span><br><span class="line">		like.lambda();</span><br><span class="line">		<span class="comment">//方法内部类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">Like3</span> <span class="keyword">implements</span> <span class="title">ILike</span></span>&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				System.out.println(<span class="string">"i like lambda3"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		like = <span class="keyword">new</span> Like3(); </span><br><span class="line">		like.lambda();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//匿名内部类</span></span><br><span class="line">		like = <span class="keyword">new</span> ILike() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"i like lambda4"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		like.lambda();</span><br><span class="line">		<span class="comment">//lambda实现</span></span><br><span class="line">		like=()-&gt;&#123;</span><br><span class="line">			System.out.println(<span class="string">"i like lambda5"</span>);</span><br><span class="line">		&#125;;</span><br><span class="line">		like.lambda();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ILike</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//void lambda2();//lambda实现中只能有一个接口</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Like</span> <span class="keyword">implements</span> <span class="title">ILike</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"i like lambda1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lambda参数的简单使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * lambda的使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">				System.out.println(<span class="string">"studying ..."</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread(()-&gt;System.out.println(<span class="string">"Coding..."</span>)).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/C:%5CUsers%5CASUS%5CDesktop%5Cimg_0153.png" alt="img_0153"></p>
<p>在Java当中，线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。<br>　　第一是创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。<br>　　第二是就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。<br>　　第三是运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。<br>　　第四是阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。<br>　　第五是死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪。</p>
<p><img src="/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/C:%5CUsers%5CASUS%5CDesktop%5Cimg_0154.png" alt="img_0154"></p>
<h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><p> 线程终止</p>
<ul>
<li>1 线程正常执行完毕 –次数</li>
<li>2 外部干涉– 使用标志位</li>
<li>不要使用 stop destroy 线程不安全</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程终止</span></span><br><span class="line"><span class="comment"> * 1 线程正常执行完毕 --次数</span></span><br><span class="line"><span class="comment"> * 2 外部干涉-- 使用标志位</span></span><br><span class="line"><span class="comment"> * 不要使用 stop destroy 线程不安全</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminateThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="comment">//1 加入标识  标记线程具体是否可以运行</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> flag =<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">	String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TerminateThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">//2 关联标识  true--&gt;运行false--》停止</span></span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(flag) &#123;</span><br><span class="line">			System.out.println(name+<span class="string">"--&gt;"</span>+i++);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//3 对外提供方法 改变标识</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">terminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.flag=<span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TerminateThread tt=<span class="keyword">new</span> TerminateThread(<span class="string">"chenye"</span>);</span><br><span class="line">		<span class="keyword">new</span> Thread(tt).start();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">99</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">88</span>) &#123;</span><br><span class="line">				tt.terminate();<span class="comment">//外部控制线程的终止</span></span><br><span class="line">				System.out.println(<span class="string">"Game Over"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"main--&gt;"</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="暂停-sleep"><a href="#暂停-sleep" class="headerlink" title="暂停 sleep"></a>暂停 sleep</h3><ul>
<li>指定当前线程阻塞的毫秒数</li>
<li>sleep存在异常InterruptedException</li>
<li>sleep时间达到后线程进入就绪状态</li>
<li>可以用来模拟网络延时、倒计时等</li>
<li>每一个对象都有一把锁，sleep不会释放锁</li>
</ul>
<h3 id="礼让-yield"><a href="#礼让-yield" class="headerlink" title="礼让 yield"></a>礼让 yield</h3><ul>
<li>礼让线程，让当前正在执行线程暂停</li>
<li>不是进入阻塞线程，而是将线程从运行状态转入就绪状态</li>
<li>让CPU调度器重新调度</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 礼让线程,暂停线程 进入就绪状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		  MyYield my=<span class="keyword">new</span>  MyYield();</span><br><span class="line">		<span class="keyword">new</span> Thread(my,<span class="string">"a"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(my,<span class="string">"b"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyYield</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;start"</span>);</span><br><span class="line">		Thread.yield();<span class="comment">//礼让  重回调度器</span></span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;start"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插队-join"><a href="#插队-join" class="headerlink" title="插队 join"></a>插队 join</h3><ul>
<li>合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞</li>
</ul>
<p>通过getState监视线程的状态</p>
<h2 id="优先级-Priority"><a href="#优先级-Priority" class="headerlink" title="优先级 Priority"></a>优先级 Priority</h2><p>java的线程优先级总共有10个级别,从1到10,1为优先级最小,10为最大。通过线程的setPriority（int）方法来设置优先级。<br>优先级也并非绝对的优先级，低优先级的线程有时候还是会先于高优先级的线程运行</p>
<p>默认的优先级是5，设置优先级要在启动之前</p>
<p><a href="https://blog.csdn.net/qq_43721475/article/details/104266214" target="_blank" rel="noopener">https://blog.csdn.net/qq_43721475/article/details/104266214</a></p>
<h2 id="守护线程-daemon"><a href="#守护线程-daemon" class="headerlink" title="守护线程 daemon"></a>守护线程 daemon</h2><p>java线程分为两种，用户线程即普通的线程包括主线程、以及守护线程。<br>守护线程主要用于后台提供服务，比如垃圾回收线程，后台记录操作日志，监控内存使用等</p>
<p>虚拟机必须确保用户线程执行完毕，不用等待守护线程执行完毕</p>
<p>守护线程与用户线程区别<br>用户线程，也叫做非守护线程。<br>1.当所有的用户线程被杀死时，jvm会退出。<br>2.用户线程可以在线程启动前手动调用setDaemon（true）的方法来把线程转化为守护线程。反之设置为false则为用户线程。<br>3.用户线程产生的线程默认为用户线程，而守护线程产生的线程默认为守护线程<br>4.守护线程可能会随时发生中断，所以不适合去访问如文件，数据库等资源，防止内存泄漏</p>
<p><a href="https://www.cnblogs.com/lixuan1998/p/6937986.html" target="_blank" rel="noopener">关于守护线程</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认用户线程 jvm等待用户线程执行完毕才会停止</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		God g=<span class="keyword">new</span> God();</span><br><span class="line">		Yourself y=<span class="keyword">new</span> Yourself();</span><br><span class="line">		Thread t=<span class="keyword">new</span> Thread(g);</span><br><span class="line">		t.setDaemon(<span class="keyword">true</span>);<span class="comment">//将用户线程设置为守护</span></span><br><span class="line">		t.start();</span><br><span class="line">		<span class="keyword">new</span> Thread(y).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Yourself</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"be happy"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"over"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">God</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;<span class="keyword">true</span>;) &#123;</span><br><span class="line">			System.out.println(<span class="string">"bless you ......"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">//	System.out.println("over");</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>所谓并发执行,是为了增强计算机系统的处理能力和提高资源利用率锁采取的一种同时操作技术.</p>
<p>异步：程序中的两部分在执行上没有顺序规定</p>
<p>同步：把异步环境下的一组并发进程,因直接制约而互相发送消息而进行互相合作,互相等待,使得各进程按一定的速度执行的过程称之为进程间的同步</p>
<p>非同步将会导致线程的不安全</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>处理多线程问题时，多个线程访问同一个对象，某些线程需要修改这个对象，这个时候需要引入线程同步。线程同步就是一种等待机制，多个需要同时访问这个对象的线程进入这个对象的<strong>等待池</strong>形成对列，等待前一个线程使用完毕后，下一个线程再使用。</p>
<h3 id="队列与锁"><a href="#队列与锁" class="headerlink" title="队列与锁"></a>队列与锁</h3><p>同一个进程的多个线程共享同一块存储空间，带来了访问冲突问题。为了保证数据在方法中被访问的正确性，在访问中加入锁机制（synchronized），当一个线程获得对象时加上锁，独占资源，其他线程必须等待。在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题。</p>
<p><strong>如果将一个大的方法声明为synchronized将会大大影响效率</strong></p>
<p><a href="https://blog.csdn.net/zhouyong723/article/details/80330383" target="_blank" rel="noopener">简单有趣的例子</a></p>
<ol>
<li><p>同步锁：Java里面的同步锁机制：当一个线程执行synchronized修饰的代码段时，会给监视器上一把锁，当另一个线程执行同样的被synchronized修饰的任务时，该线程就需要关注该监视器有没有上锁，没有才能执行，否则就阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Task task = <span class="keyword">new</span> Task();</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"顾客正在挑选衣服..."</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"顾客正在试衣服..."</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"顾客正在结账..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Task task = <span class="keyword">new</span> Task();</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		......................................</span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">"顾客正在试衣服..."</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		............................</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>互斥锁：当两个synchronized锁的对象（监视器）是同一个，修饰的代码片段不同时，那么这些代码片段所代表的任务是互斥的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Task task = <span class="keyword">new</span> Task();</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">"吃饭..."</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">"看电视..."</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>死锁现象：这里是因为滥用锁对象造成的，大家可以将两个锁对象（监视器）换成同一个对象，程序就会向下继续运行，但是该程序继续向下运行并没有什么意义</p>
</li>
</ol>
<p>简单的死锁的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Task task = <span class="keyword">new</span> Task();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">				task.methodA();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">				task.methodB();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object a = <span class="keyword">new</span> Object();</span><br><span class="line">	<span class="keyword">private</span> Object b = <span class="keyword">new</span> Object();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"开始执行A方法"</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">synchronized</span>(a)&#123;</span><br><span class="line">			System.out.println(<span class="string">"对A方法上锁"</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"开始调用B方法"</span>);</span><br><span class="line">			methodB();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"A方法执行完毕"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"开始执行B方法"</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">synchronized</span>(b)&#123;</span><br><span class="line">			System.out.println(<span class="string">"对B方法上锁"</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"开始调用A方法"</span>);</span><br><span class="line">			methodA();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"B方法执行完毕"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="synchronized块"><a href="#synchronized块" class="headerlink" title="synchronized块"></a>synchronized块</h3><p>同步块 synchronized(obj){} obj 称之为同步监视器</p>
<p>同步监视器的执行过程：</p>
<ol>
<li>第一个线程访问，锁定同步监视器，执行其中的代码</li>
<li>第二个线程访问，发现同步监视器被锁定，无法访问</li>
<li>第一个线程访问完毕，解锁同步监视器</li>
<li>第二个我线程访问，发现同步监视器未锁，锁定并访问</li>
</ol>
<p>普通块、局部块、静态块</p>
<h3 id="电影院订票系统1-0"><a href="#电影院订票系统1-0" class="headerlink" title="电影院订票系统1.0"></a>电影院订票系统1.0</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟电影院购票系统</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HappyCinema</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Cinema c1=<span class="keyword">new</span> Cinema(<span class="string">"星河国际"</span>,<span class="number">20</span>);</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Customer(c1,<span class="number">2</span>),<span class="string">"chenye"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Customer(c1,<span class="number">3</span>),<span class="string">"zmj"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顾客</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	Cinema ci;</span><br><span class="line">	<span class="keyword">int</span> seats;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Cinema ci, <span class="keyword">int</span> seats)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.ci = ci;</span><br><span class="line">		<span class="keyword">this</span>.seats = seats;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(ci) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">boolean</span> flag=ci.bookTickets(seats);</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"订购成功"</span>+Thread.currentThread().getName()+<span class="string">"--位置为："</span>+seats);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"订购成功"</span>+Thread.currentThread().getName()+<span class="string">"-出票失败，位置不够"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//影院</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cinema</span></span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> avilable;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cinema</span><span class="params">(String name, <span class="keyword">int</span> avilable)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.avilable = avilable;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bookTickets</span><span class="params">(<span class="keyword">int</span> seats)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"可用的位置"</span>+avilable);</span><br><span class="line">		<span class="keyword">if</span>(seats&gt;avilable) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		avilable=avilable-seats;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="电影院订票系统2-0"><a href="#电影院订票系统2-0" class="headerlink" title="电影院订票系统2.0"></a>电影院订票系统2.0</h3><p>使用List容器，要保证每一个位子只能由一个顾客选中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟电影院购票系统</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HappyCinema2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//可用的位置</span></span><br><span class="line">		List&lt;Integer&gt; available=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">		available.add(<span class="number">1</span>);</span><br><span class="line">		available.add(<span class="number">2</span>);</span><br><span class="line">		available.add(<span class="number">3</span>);</span><br><span class="line">		available.add(<span class="number">4</span>);</span><br><span class="line">		available.add(<span class="number">5</span>);</span><br><span class="line">		available.add(<span class="number">6</span>);</span><br><span class="line">		available.add(<span class="number">7</span>);</span><br><span class="line">		<span class="comment">//顾客需要的位置</span></span><br><span class="line">		List&lt;Integer&gt; seat3=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">		seat3.add(<span class="number">1</span>);</span><br><span class="line">		seat3.add(<span class="number">2</span>);</span><br><span class="line">		List&lt;Integer&gt; seat4= <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">		seat4.add(<span class="number">4</span>);</span><br><span class="line">		seat4.add(<span class="number">5</span>);</span><br><span class="line">		Cinema2 c=<span class="keyword">new</span> Cinema2(<span class="string">"星河国际"</span>,available);</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Customer2(c,seat3),<span class="string">"chenye"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Customer2(c,seat4),<span class="string">"zmj"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顾客</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	Cinema2 ci;</span><br><span class="line">	List&lt;Integer&gt; seats;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Customer2</span><span class="params">(Cinema2 ci, List&lt;Integer&gt; seats)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.ci = ci;</span><br><span class="line">		<span class="keyword">this</span>.seats = seats;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(ci) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">boolean</span> flag=ci.bookTickets(seats);</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"订购成功"</span>+Thread.currentThread().getName()+<span class="string">"--位置为："</span>+seats);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"订购成功"</span>+Thread.currentThread().getName()+<span class="string">"-出票失败，位置不够"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//影院</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cinema2</span></span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	List&lt;Integer&gt; available;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cinema2</span><span class="params">(String name,List&lt;Integer&gt; available)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//super();</span></span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.available = available;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bookTickets</span><span class="params">(List&lt;Integer&gt;seats)</span> </span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">"欢迎您选购，可用的位置"</span>+available);</span><br><span class="line">		List&lt;Integer&gt;copy=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">		copy.addAll(available);</span><br><span class="line">		<span class="comment">//相减</span></span><br><span class="line">		copy.removeAll(seats);</span><br><span class="line">		<span class="comment">//判断大小</span></span><br><span class="line">		<span class="keyword">if</span>(available.size()-copy.size()!=seats.size()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//成功</span></span><br><span class="line">		available=copy;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><p><a href="https://blog.csdn.net/qq_39158142/article/details/95049855" target="_blank" rel="noopener">这是一个可爱的链接–&gt;java并发容器</a></p>
<h2 id="并发协作"><a href="#并发协作" class="headerlink" title="并发协作"></a>并发协作</h2><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><ul>
<li>synchronized可阻止并发更新同一个共享资源，实现了同步</li>
<li>synchronized不能用来发现不同线程之间的信息传递（通信）</li>
</ul>
<p>Java提供了3个方法解决线程之间的通信问题，都只能在同步方法或者同步代码块中使用，否则会抛出异常</p>
<ul>
<li>final void wait(long timeout)</li>
<li>final void notify()</li>
<li>final void notifyAll()</li>
</ul>
<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p><img src="/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/C:%5CUsers%5CASUS%5CDesktop%5Cimg_0156.png" alt="img_0156"></p>
<h3 id="管程法解决生产者消费者模型"><a href="#管程法解决生产者消费者模型" class="headerlink" title="管程法解决生产者消费者模型"></a>管程法解决生产者消费者模型</h3><p>伪代码思路：借助缓冲区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;思路</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1.思考需要哪些对象?</span><br><span class="line">&#x2F;&#x2F; 生产 , 消费 , 产品 , 容器</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.分工</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">    生产者只管生产</span><br><span class="line">    消费者只管消费</span><br><span class="line">    鸡: 实体类</span><br><span class="line"></span><br><span class="line">    容器 :</span><br><span class="line"></span><br><span class="line">    容器添加数据.</span><br><span class="line">    要判断容器是否满 , 满了等待消费者消费</span><br><span class="line">    没有满,通知生产者生产</span><br><span class="line"></span><br><span class="line">    容器减少数据</span><br><span class="line">    判断还有没有数据, 没有数据的话 . 等待生产者生产</span><br><span class="line">    消费完毕 , 通知生产者生产</span><br><span class="line"> *&#x2F;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「dream_Felix」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;yalu_123456&#x2F;article&#x2F;details&#x2F;91050054</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 协作模型：生产者消费者实现方式一：管程法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chenye</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cooparation</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	SynContainer container=<span class="keyword">new</span> SynContainer();</span><br><span class="line">	<span class="keyword">new</span> Productor(container).start();</span><br><span class="line">	<span class="keyword">new</span> Consumer(container).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Productor</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	SynContainer container;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Productor</span><span class="params">(SynContainer container)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.container = container;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//生产</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"生产--》"</span>+i+<span class="string">"个馒头"</span>);</span><br><span class="line">			container.push(<span class="keyword">new</span> Steamedbun(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	SynContainer container;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(SynContainer container)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.container = container;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//消费</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"消费--》"</span>+container.pop().id+<span class="string">"个馒头"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynContainer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	Steamedbun[] buns=<span class="keyword">new</span> Steamedbun[<span class="number">10</span>];<span class="comment">//存储容器</span></span><br><span class="line">	<span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//计数器</span></span><br><span class="line">	<span class="comment">//存储 生产</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Steamedbun bun)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//何时能生产 容器存在空间</span></span><br><span class="line">		<span class="comment">//不能生产 只有等待</span></span><br><span class="line">		<span class="keyword">if</span>(count==buns.length) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.wait();<span class="comment">//线程阻塞  消费者通知生产者解除</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//存在空间 可以生产</span></span><br><span class="line">		buns[count]=bun;</span><br><span class="line">		count++;</span><br><span class="line">		<span class="comment">//存在数据 可以通知消费了</span></span><br><span class="line">		<span class="keyword">this</span>.notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取 消费</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Steamedbun <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//何时能消费  容器中是否存在数据</span></span><br><span class="line">		<span class="comment">//没有数据 只有等待</span></span><br><span class="line">		<span class="keyword">if</span>(count==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.wait();<span class="comment">//线程阻塞  有生产者通知消费时解除阻塞</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//存在数据可以消费</span></span><br><span class="line">		count--;</span><br><span class="line">		Steamedbun bun=buns[count];</span><br><span class="line">		<span class="keyword">this</span>.notifyAll();<span class="comment">//存在空间，可以唤醒对方生产</span></span><br><span class="line">		<span class="keyword">return</span> bun;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Steamedbun</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> id;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Steamedbun</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.id = id;</span><br><span class="line">		&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号灯法"><a href="#信号灯法" class="headerlink" title="信号灯法"></a>信号灯法</h3><p>思路：借助标志位</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;生产者消费2</span><br><span class="line">&#x2F;&#x2F;生产者---&gt;演员</span><br><span class="line">&#x2F;&#x2F;消费者---&gt;观众</span><br><span class="line">&#x2F;&#x2F;产品:信号灯---&gt;电视-----&gt;声音</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TV tv = <span class="keyword">new</span> TV();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Player(tv).start();</span><br><span class="line">        <span class="keyword">new</span> Watcher(tv).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    TV tv;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(TV tv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.tv.play(<span class="string">"节目:快乐大本营播放中"</span>);</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.tv.play(<span class="string">"广告:抖音,记录美好生活"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    TV tv;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Watcher</span><span class="params">(TV tv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            tv.watch();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电视</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TV</span></span>&#123;</span><br><span class="line">    <span class="comment">//演员说话 , 观众等待</span></span><br><span class="line">    <span class="comment">//观众观看 , 演员等待</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说话</span></span><br><span class="line">    String voice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表演</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String voice)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//演员等待</span></span><br><span class="line">        <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"表演了"</span>+voice);</span><br><span class="line">        <span class="keyword">this</span>.voice = voice;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让观众观看</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//观看</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//观众等待</span></span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"观众听到了: "</span>+voice);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通知演员说话</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/yalu_123456/article/details/91050054" target="_blank" rel="noopener">Java多线程：线程通信：管程法和信号灯法，线程池的使用</a></p>
<h2 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h2><h3 id="任务定时调度"><a href="#任务定时调度" class="headerlink" title="任务定时调度"></a>任务定时调度</h3><p>通过Timer和Timetask，我们可以实现定时启动某个线程，在java.util 中</p>
<h3 id="quartz"><a href="#quartz" class="headerlink" title="quartz"></a>quartz</h3><h3 id="HappenBefore"><a href="#HappenBefore" class="headerlink" title="HappenBefore"></a>HappenBefore</h3><h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><p>保证线程间变量的可见性，线程对变量进行修改之后，要立刻回写到主存，线程对变量读取的时候，要从主内存中读，而不是缓存</p>
<h3 id="dcl单例模式"><a href="#dcl单例模式" class="headerlink" title="dcl单例模式"></a>dcl单例模式</h3><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><h3 id="CAS原子操作"><a href="#CAS原子操作" class="headerlink" title="CAS原子操作"></a>CAS原子操作</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
  </entry>
  <entry>
    <title>HTML&amp;CSS学习笔记</title>
    <url>/2020/03/21/HTML&amp;CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>写于1月18日至1月26日左右</p>
<h1 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h1><p>1.HTML中不区分大小写</p>
<p>2.注释不能嵌套</p>
<p>3.标签必须结构完整</p>
<p>4.XML 更加严谨</p>
<p>5.浏览器尽最大努力正确加些页面，自动修正，但有些情况会错误修正</p>
<p>6.HTML标签可以嵌套，但是不能交叉嵌套</p>
<p>7.使用内联框架<strong><em>iframe</em></strong>可以引入一个外部的页面  使用iftrame来创建一个内联框架 </p>
<p>现实开发中不推荐使用内联框架，内联框架中的内容不会被搜索引擎所检索</p>
<p><img src="../images/code.jpg" alt></p>
<a id="more"></a>

<p>8.超链接：从一个页面跳转到另一个见面 用标签a&lt;&gt;(a在&lt;&gt;中间）来创建一个超链接</p>
<p>属性： href：指向链接跳转的目标地址， 相对路径or完整地址</p>
<p>a标签中的target属性可以用来指定打开链接的位置 </p>
<ol>
<li>_self：默认值 在当前窗口打开</li>
<li>_blank:在一个新的窗口中打开链接</li>
</ol>
<p><strong><em>可以设置一个内联框架的name属性值，链接将会在指定的内联框架中打开</em></strong></p>
<p>用#代表空链接 默认为页面的顶部</p>
<p>HTML中有一个属性作为标签的唯一标识：id</p>
<p>9.center标签中的内容会默认在页面中居显示</p>
<p>10.发送电子邮件的超链接，自动打开计算机中默认的邮件客户端</p>
<p><a href="mailto:xxx@xxx.com">   联系我们  </a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">SRC属性:</span><br><span class="line">相对路径：</span><br><span class="line">返回路径：..&#x2F; 返回上一级目录  </span><br><span class="line">--&gt;</span><br><span class="line">&lt;!-- </span><br><span class="line">图片格式</span><br><span class="line">JPEG：多颜色，可以压缩，但是不支持透明 一般用来保存照片</span><br><span class="line">GIF： 支持的颜色较少，只支持简单透明，支持动态图</span><br><span class="line">PNG：支持的颜色多，支持复杂透明</span><br><span class="line">图片使用原则：</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>





<h1 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h1><p><strong>css笔记</strong></p>
<p>层叠样式表 <code>cascading style sheets</code></p>
<p>1.内联样式：样式直接编写到style属性元素中 只对当前元素中的内容起作用</p>
<p>2.也可以将css样式编写到head中的style标签里，将样式表编写的style标签中，通过css选择器选中指定的元素，为这些元素一起设置样式。也可以将表现和结构进一步分离（推荐使用） （少用标签选择器）</p>
<p>3.外部的css文件 .css 将样式表写到外部的css文件中，通过link标签将外部的cs文件引入到当前的页面当中 这样外部文件css样式表将会应用到当前页面中 </p>
<p>css样式统一写到尾部的样式表中，完全使结构和表现分离，可以使样式表在不同的页面表中使用，虽大限度使演示表复用</p>
<p>link标签引入可以利用浏览器的缓存，加快用户访问的速度提高，开发中推荐只用外部css文件（最不推荐内联样式）</p>
<p>4.style标签里不能用HTML注释 </p>
<p>/<em>css的注释，必须写在tyle标签中或者css文件中</em>/</p>
<p>css语法：选择器    声明块</p>
<p>选择器：选中页面中的指定元素，并且将声明块中的样式应用到选择器对应的元素上</p>
<p>声明块：紧跟在选择器后用{}，一组一组的名值对结构，一个声明块中有多个声明用；隔开</p>
<p>声明的样式名和样式值之间使用：来连接</p>
<p>5.块元素 <code>div</code>就是一个块元素，独占一行无论内容有多少 p h1 h2 h3…</p>
<p>div这个标签没有任何语义，纯粹的块元素，不会被里面的元素设置任何默认样式，主要用于给页面布局 </p>
<p>6.span 是一个内联元素（行内元素），只占自身大小的</p>
<p>常见内联元素： a img iframe span  </p>
<p>span 也没有任何语义，用来选中专门的文字，为文字来设置样式</p>
<p><strong><em>一般情况下只使用块元素去包含内联元素，而不会用内联包含块</em></strong></p>
<ul>
<li>a元素可以包含任意元素，除了它本身</li>
<li>p元素不可以包含任何块元素</li>
</ul>
<p>7.<strong><em>类选择器</em></strong>：通过元素的class属性选中一组元素 class在标签中</p>
<p>style中用 . +类名选中</p>
<p><strong><em>选择器分组</em></strong>：通过选择器同时选中多个选择器对应的元素</p>
<p>语法： 选择器1，选择器2，..{}</p>
<p><strong><em>通配选择器</em></strong> </p>
<p><strong><em>复合选择器</em></strong>    选择器1选择器2…{}</p>
<p>·#· id选择器      .(点)：类选择器</p>
<p>后代元素选择器： 祖先元素（空格）后代元素{}</p>
<p>子元素选择为其：父元素&gt; 子元素{}（IE6以下不支持子元素选择器）</p>
<p>8.伪类：专门用来表示元素的一种特殊的状态 比如：访问过的超链接，普通的超链接，获取焦点的文本框  ；当我们要为这些特殊状态元素设置样式时使用伪类</p>
<p>浏览器通过历史记录判定是否访问过，由于涉及用户隐私使用visited时只能设置字体颜色</p>
<p>正常链接 a<code>：link</code></p>
<p>访问过的连接a<code>：visited</code></p>
<p>鼠标滑过的连接 a<code>:hover</code>表示鼠标</p>
<p>超链接被点击 a<code>：active</code></p>
<p>获取焦点 -<code>：focus</code></p>
<p>指定元素前 -<code>:before</code></p>
<p>指定元素后 -：<code>after</code></p>
<p>选中的元素 -<code>::selection</code>（两个冒号 注意）</p>
<p>hover和active也可以给其他元素设置</p>
<p>9.伪元素：<code>first-letter first-line</code></p>
<p>通过css添加的字符无法选中</p>
<p>10.属性选择器：【属性名=属性值】</p>
<p> 使用[]  p[title]{} p[title=hello]{} </p>
<p>p[title^=”ab”]{} 属性名以ab开头</p>
<p>p[title$=”c”]{} 属性名以c为结尾</p>
<p>p[title*=”c”]{}属性名中包含c即可</p>
<p>title属性可以给任何标签指定</p>
<h1 id="day3"><a href="#day3" class="headerlink" title="day3"></a>day3</h1><p>1.子元素的伪类： p:first-child p为指定标签 若用*为所有标签</p>
<p>last-child nth-child(num):参数选择指定位置 even参数选择偶数 odd选择奇数</p>
<p>first-of-type last-of-type nth-of-type:type指的是当前类型的子元素的排列</p>
<p>2.兄弟元素选择器：  语法：前一个+后一个 选中一个元素后面紧挨着的指定的兄弟元素</p>
<p>前一个~后一个 选中后面所有的兄弟元素</p>
<p>3.否定伪类：从已选中的元素中剔除某些元素 not(.hello)</p>
<p>4.样式的继承 继承 透过 transparent</p>
<p>5.选择器的优先级：</p>
<ul>
<li>内联（行列）样式 优先级1000</li>
<li>id选择器：100</li>
<li>类和伪类：10</li>
<li>元素选择器：1</li>
<li>通配*，优先级0</li>
<li>继承的样式，没有优先级</li>
</ul>
<p><strong>* 选择器中包含多种选择器的时候要将多种选择器的优先级相加然后再比较*</strong></p>
<p>选择器优先级计算不会超过他的最大的数量级，如果优先级一样选择靠后的样式</p>
<p>样式的最后添加一个！important，该样式获得一个最高的优先级：<br><code>.p{
                background-color: greenyellow！important;
            }</code></p>
<p>6.伪类顺序 link visited hover active</p>
<h2 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h2><p>1.em和strong表示一个强调的内容 </p>
<p> em主要表示语气上的强调，浏览器中默认为斜体</p>
<p> strong表示强调的内容，语义更强烈，默认用粗体</p>
<p>单纯改变样式，和语义无关：i标签 斜体； b标签 加粗；</p>
<p>small cite（表示参考的内容） q标签：表示引用； blockquote：长引用（块级引用）</p>
<p>sup标签：上标   ； sub标签：下标</p>
<p>del标签：删除的内容； ins标签：下划线 ；pre标签：预格式标签，保留格式，不会忽略多个空格（无语义） ； code标签：语义标签表示代码，与pre一起使用</p>
<h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><ul>
<li>无序列表</li>
<li>有序列表</li>
<li>定义列表</li>
</ul>
<p>无序列表：ul创建无序列表，li在ul中创建一个一个的列表项 一个li就是一个列表项</p>
<p>通过ul中的type属性修改项目符号  disc; square; circle  ul，li都是块元素</p>
<p>修改默认样式，css的style标签中</p>
<p>有序列表；ol 使用有序的符号作为项目符号 type属性指定序号的类型</p>
<p>type可选：1，a/A, i/I 【可以有序列表无序列表互相嵌套】</p>
<p>定义列表：dl来创建，两个子标签<dt>:定义的内容<dd>对定义内容的描述</dd></dt></p>
<h2 id="文本格式"><a href="#文本格式" class="headerlink" title="文本格式"></a>文本格式</h2><p>1.1em=1font-size</p>
<p>2.rgb：0~255（，，） 或者使用16进制 #ffffff 两位重复的颜色，可以简写</p>
<p>3.字体：设置文字的大小，浏览器中默认16px，font-size并不是文字本身的大小，是格的高度，用font-family指定文字的字体，如果浏览器不支持仍使用默认，使用多个字体浏览器优先使用前面的字体，如果前面的没有再尝试下一个</p>
<p>serif：衬线字体</p>
<p>sans-serif：非衬线字体</p>
<p>monospace：等宽字体</p>
<p>cursive：草书字体</p>
<p>fantasy：虚幻字体</p>
<p>4.CSS中通过行高来设置行距： line-height:40px（80%或者是百分数；或者是一个数值，字体大小的相应倍数） 与font-size一起使用</p>
<p>font：A px/B px 字体大小/行高</p>
<ol start="5">
<li><ul>
<li>text-transform设置文本的大小写</li>
<li>text-decoration添加文本的修饰【超链接会默认添加下划线】</li>
<li>letter-spacing：字间距 ；word-spacing 单词之间的间距</li>
<li>text-align：文本对齐方式  left right center justufy(两端对齐)</li>
<li>text-indent：设置首行缩进 一般以em作为单位</li>
</ul>
</li>
</ol>
<h2 id="盒子模型box"><a href="#盒子模型box" class="headerlink" title="盒子模型box"></a>盒子模型box</h2><p>1.内容区 内边距(padding)  边框 (border) 外边距(margin)</p>
<p>2.垂直相邻外边距发生重叠，兄弟元素之间的相邻外边距取最大值而不是求和</p>
<p>如果父子元素垂直外边距相邻，子元素的外边距会设置给父元素</p>
<p>两种处理方法</p>
<p>3.通过display样式改变元素的类型  </p>
<p>inline：将一个元素作为内联元素显示</p>
<p>block：将一个元素设置为块元素显示</p>
<p>inline-block：转换为行内块元素 可以设置宽高又独占一行</p>
<p>visibility： visible默认 hidden 元素不会显示但仍占据位置</p>
<p>4.overflow 属性：可选 visible hidden scroll  auto</p>
<h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><p>文档流在网页的最顶层，表示的页面中的位置，创建的元素默认在文档流中</p>
<p>文档在文档流中的特点</p>
<ul>
<li>块元素：独占一行，自上向下【默认宽度 默认高度】</li>
<li>内联元素：只占自身大小，默认从左向右排列【宽度 高度】</li>
</ul>
<p>inline-block</p>
<p>1.float属性使元素浮动，脱离文档流：可选 none left right</p>
<h1 id="day5"><a href="#day5" class="headerlink" title="day5"></a>day5</h1><p>1.高度塌陷（没有深入了解）</p>
<p>2.导航条设计</p>
<p>3.PS的简单认识</p>
<p>4.div.box$*3 建立三个div元素 box123</p>
<p>5.相对定位 绝对定位 固定定位 元素的position属性</p>
<p>6.开启定位的元素使用z-index修改元素的层级</p>
<p>7.opacity可以用来设置元素背景的透明 需要一个0-1之间的值 0表示完全看不见 1完全不透明 opacity在IE8及以下不支持 需要使用filter属性 alpha（opacity=50）</p>
<p>8.设置背景图片 background-img=url（相对路径）</p>
<p>background-repeat属性 repeat no-repeat repeat-x repeat-y 设置背景图片是否重复</p>
<p>背景图片默认贴着页面左上角显示 background-position属性调整:top left right bottom center 或者直接指定偏移量 -px -px 第一个是水平偏移第二个是垂直</p>
<p>background-attachment属性设置背景是否固定 fixed scroll </p>
<p>background简写属性 不写表示默认属性</p>
<p>9.图片整合技术：多个图片整合成一个图片同时加载，解决闪烁问题</p>
<h1 id="day6"><a href="#day6" class="headerlink" title="day6"></a>day6</h1><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>1.table 标签 使用tr表示表格的一行 td创建一个单元格</p>
<p>table是一个块元素</p>
<p>2.colspan横向的合并单元格 <td colspan="2">D3</td></p>
<p>   rowspan纵向合并单元格</p>
<p>3.table的属性 width margin border border-spacing border-collapse</p>
<p>设置的合并后border-spacing自动失效</p>
<p>4,th</p>
<p>5.长表格 ： 表头 表格的主体 表格底部 都是table的子标签</p>
<p>​     <thead> <tbody> <tfoot> 需要直接写到table中，tr写在这些标签中</tfoot></tbody></thead></p>
<p>如果没有tbody，浏览器自动添加tbody并把tr放在其中</p>
<p>6.完善clearfix</p>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>1.网页中个人信息通过表单提交给服务器 比如搜索框</p>
<p>2.使用form 标签创建一个表单 必须指定一个action属性，指向一个服务器</p>
<p>提交表单时会提交到action属性对应的地址</p>
<form action="target.html"> </form>
3.使用input创建一文本框，type属性是text，如果希望表单中的数据提交到服务器中，还必须给表单提供一个那么属性，name表示提交内容的名字 

<p>用户填写的信息会附在url地址的后边以查询字符串的形式发送给服务器</p>
<p>url地址？查询字符串</p>
<p>格式： 属性名=属性值</p>
<p>4.密码框 不能用type的text属性，明文    修改为type=“password”</p>
<p>5.单选按钮 type属性：radio  name属性相同的是同一组按钮 使用label标签可以选中文字</p>
<p>value属性必须设置</p>
<p>6.多选框 type属性CheckBox</p>
<p>7.下拉列表 使用select标签 option作为子标签 </p>
<p>如果希望在单选按钮或者是多选框中指定默认选中的选项，可以在希望选中的选项中添加checked=“checked”属性 selected=“selected”</p>
<p>select添加一个multiple=“multiple”，下拉列表变为一个多选的下拉列表</p>
<p>创建optgroup分组 添加label标签进行分组</p>
<p>8.type=“reset” 创建重置按钮 ，点击后表单内容恢复为默认值 </p>
<p>9.除了使用input 也可以使用button标签来创建按钮（成对出现，可以插入图片）</p>
<p>10.在表单中使用fieldset为表单项进行分组，将表单项中的同一组放到一个fieldset中，在fieldset中使用legend子标签，来指定组名</p>
<h2 id="框架集"><a href="#框架集" class="headerlink" title="框架集"></a>框架集</h2><p>框架集与内联框架的作用相似，都是用在一个页面中引入其他的外部页面，框架集可以引用多个页面，内联框架只能引入一个，h5标准中，推荐使用框架集</p>
<p>使用frameset来创建一个框架集，<strong><em>注意frameset和body不能出现在同一个页面中</em></strong></p>
<p>frameset中使用frame子标签来指定要引入的页面</p>
<p>属性：rows cols 指定框架集中的页面的排列，这两个属性frameset必须指定一个</p>
<p>frameset中也能嵌套frameset</p>
<p><strong><em>frameset和iframe一样，里面的内容都不会被搜索引擎检索。</em></strong></p>
<p><strong><em>使用框架集意味着网页中不能有自己的内容，只能引入其他的页面，每单独加载一个界面，浏览器都需要重新发送一次请求，引入几个界面就要发送几次请求</em></strong></p>
<h2 id="Hack-解决兼容性"><a href="#Hack-解决兼容性" class="headerlink" title="Hack 解决兼容性"></a>Hack 解决兼容性</h2><h3 id="CSS参考手册"><a href="#CSS参考手册" class="headerlink" title="CSS参考手册"></a>CSS参考手册</h3><p>CSS Hack不到万不得已的情况尽量不要使用</p>
<p>Hack有风险，使用需谨慎</p>
<p>1.条件Hack</p>
<p>&lt;IE6中png的修复&gt;</p>
<p>使用JavaScript来解决该问题，向页面中引入一个外部的JavaScript文件</p>
<p>CSS Hack实际上指一个特殊代码，这段代码只在特殊的浏览器中执行，而其他浏览器不能识别</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if IE 6]</span></span><br><span class="line"><span class="comment"> &lt;p&gt;为了您和家人的健康，请远离IE6！！&gt;</span></span><br><span class="line"><span class="comment">&lt;/p&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.属性Hack</p>
<h1 id><a href="#" class="headerlink" title></a></h1><p>后记：MarkDown的精髓还没有仔细体会，仍在学习中。当前水平大体是将他作为普通文本格式的替代品，敬请谅解。</p>
<p>联系方式：<a href="mailto:213181848@seu.edu.cn">213181848@seu.edu.cn</a> </p>
]]></content>
  </entry>
  <entry>
    <title>陈烨的 2019年度总结</title>
    <url>/2020/03/21/%E9%99%88%E7%83%A8%E7%9A%84%202019%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="陈烨的-2019年度总结"><a href="#陈烨的-2019年度总结" class="headerlink" title="陈烨的 2019年度总结"></a><strong>陈烨的</strong> 2019年度总结</h2><h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a><strong>回顾</strong></h4><p>2015 2016 2017 2018 2019，每年的年度总结都不曾落下，写在日记里。</p>
<p>之前的文字现在看起来不如当时那般融入了情感，只能略微地回忆起当时的心情。</p>
<p>2015年12月31日，“月考失利，这样的成绩令人无地自容。”</p>
<p>2016年12月31日，“和几乎每一次放假一样，一到家就是鸡飞狗跳。”“然而仿佛一年过去了，我仍不曾真实地记录下每一点想法。”“眨眼，我的笔就跨过了三个年头。”“那么眨眼间，下一幕又是什么呢？”</p>
<p>2017年12月31日，衡水，昆仑大酒店。“爸爸和学校的老师前几日来过了。””我选择了隐忍，是为了图强。”“我的高考，妹妹的诞生。”</p>
<p>2018年12月31日，南京，“到了大学，反倒写日记的时间少了。”“一个人来到这个学校，每一天都值得铭记。”2019年1月1日。“想在跨年晚会前把日记写完，但高估了思维转化为文字落在纸面上的时间了。”“放手去追求，放手爱自由。”“ ”即使倒下，也要朝着未名湖的方向” 。”“已经走远了，也许会回来，也许不会。我不想停留在这种记忆里了。”“2019，向往自由。”</p>
<p>2019年12月31日，说来就来了。</p>
<p>（未完）</p>
<p> <img src="../images/naruto.jpg" alt></p>
<a id="more"></a>

<h4 id="2019"><a href="#2019" class="headerlink" title="-2019"></a><strong>-2019</strong></h4><p>其实可以很好地从时间线上回忆，因为“摇摆依旧”跨年演唱会就在前天。之所以这么说是因为昨天是”廿廿不忘”。</p>
<p>并不是所有的念念不忘都有回响的，可是更多的是种寄托。今年的日记只有八页，仔细翻阅也并无记载太多的东西，值得一提的是有段时间开了一个叫做“ cybryant ”的小屋”的公众号，把日记试的文章写在那里，大概也有八九篇罢。后来因为社会实践停运了，再后来也无暇去打理，也就没有重新建立的打算。</p>
<p>19年的伊始，经历了第一个考试周，那时候保持着十二点睡觉八点钟起床的考试周专属作息，却日复一日地饱受作息不统一的室友带来的的烦恼。考罢倒也平平淡淡的，想来大学的第一个寒假没有做什么事情，有的同学趁此学完了雅思托福，或者是去日本游玩，或者是静下心来学点什么。我没有，单纯地只是和家人在一起，带小孩，看着妹妹一天天地长大（那时候她还是一个彻彻底底的婴儿），更多的时间还是同家里的兄弟们出去玩耍，日常地九十点钟回家，街上都没有什么人了，自然是十分开心的。还认识了马燕儿，一个十分开朗的小姑娘。其实寒假不做点什么，实在是血亏一笔。</p>
<p>返校后就开始一到十六周的计数了，清楚记得前四周没有C++课程，倒也不算十分忙碌。同样十分悠闲的刘超颖造访南京，恐怕是整个三月份最愉快的事情，我们去了玄武湖，去了五台山的先锋书店，去了钟山，总之这次出游十分惬意，也算是给机械运转一般的生活增添了一些焠出的火花。后来这个学期刘超颖给我写过几封信，都用的是平邮，贼慢，每次她告诉我寄信了然后我就盼着能在围合大厅的信报栏上看到我的名字，生活就多了一些期盼。那个时候觉得宣城和南京更近一些就好了，也有过去一次宣城的想法，后来这种想法就消失了。</p>
<p>这个学期在忙些什么我倒有个数。科协新媒的活我大都是划水过了，似乎副部长也看出了我的想法，也并没有过多的说什么，我想所具有的责任感与此并不冲突。那个时候忙着学院院运会的事情，前前后后地应该是好几周，包括校运会。同体育部在一起是我喜欢的，我选择的是我热爱的，其实热爱所选择的这一说法略微有一些牵强附会。后来我毫不犹豫地竞选了体育部部长，也是选择了我所热爱的。很幸运遇到了许朝阳这样的好学长，自然而然地称兄道弟，交流了很多想法，尤其是在网安这样没有16级的学院，学长的经验尤为重要。他同我讲了一些未来的规划的建议，有时也彻夜聊聊感情，也不知道有啥好聊的哈哈。当然赵笛言也很棒，很高兴能够遇到这样的学姐。最后忙碌的是暑假的社会实践了，从立项申请到答辩再到后面的组织以及出发，说是19年最令人操心的恐怕就是这个事情。坐在前往南昌的高铁上还没有确定好行程，中间强行改了两次，前往山里的井冈山下七乡，磕磕绊绊总算是把社会实践给完成了。这一次经理让我意识到作为组长要统筹兼顾到很多东西，有时候决策的失误是允许被原谅的。当时我提出了一个系统与接口的理论，每一个组员都是一个部件，一个接口，他们需要的只是完成系统分派的任务，然后并不十分清楚其他接口正在做的事情，担任这个系统的就是组长，必须根据每一个部件的能力，特点，目前手头已经接收的任务进行分配。这不是P2P，系统保证每一接口都在高效运作整体理应是高效的。当然少不了矛盾的存在。在社会实践期间，文俊给了我许多帮助。暑假里他去美国了，如我所想回来讲述了一些十分有趣的故事。</p>
<p>期间端午节去了一次上海，刚好在高考那两天，写了一篇很长的文字来缅怀一下自己的高三。似乎暑假里也没有做什么有意义的事情，想学一些东西最后也没有学通到能直接用上，也不过是陪陪妹妹，打打游戏，跟朋友玩之类的。暑假里为了社会实践也占去了很多时间。</p>
<p>东大的返校全国再找不到更早的，回学校开始了短学期，对新西兰大学的外教Lee印象很深，反倒是对MFC怎么写忘得一干二净。这么说着说着，也就到了本学期的事情了。把其他任何事情都推了，单单留下一个体育部部长，说来闲云野鹤似的，其实并不。有时候想我是不是管的太多，搞得太复杂，无论是否是这样，这个学期已经是过去了。我逐渐明白一个道理，我喜欢的是这个事情本身，这不过是我喜欢的事情之一，而已。</p>
<p>九月中秋我去了杭州一次，一半陪家人，一半找朋友。在西湖白堤上看中秋的满月别有风趣。书瑜哥哥也会和我讲很多，走的时候叔叔给了一笔钱让我拿去玩耍，这也太棒了。九月底罗宇坤来过南京一次。十月，国庆节，小峰来南京，和king黄一起去游乐园玩儿，高中一起的伙伴在异乡相聚还挺有一些触动的，三个人住在南京的乡下挤在大床上聊到很晚。近来都十分平淡，除了连续几天在机电平台调试小车最后还拉胯让我着实暴躁了一回。有种感觉，莫名地到了学期末，总觉得忙完这件事就好了忙完那件事就好了，可是这种事情一件又一件地来像流水一样，无暇顾及其他。然后，就年底了。</p>
<h4 id="跨年"><a href="#跨年" class="headerlink" title="跨年"></a><strong>跨年</strong></h4><p>跨年前的日子我不知如何用一个恰当的词语来形容，踌躇了好久，终于鼓起勇气问张湄婧要不要一起去看跨年演唱会……后来跟大伙去景枫来回以及等待的时间远超了预期，结果就错过了…现在回想起，应该是2019年最后一个遗憾吧。</p>
<p>这也大概是我2020年伊始的最大动力。</p>
<p>最终跨年找到了刘新元，错综交集的老友，他讲了一些心里一直想说的话，最后我们一起看了一会儿演唱会，就跟365天前一样，一起倒计时，只不过这次迎来的是2020.</p>
<p>零点的时候和几个朋友互相打电话祝福，算是跨年的传统。</p>
<h4 id="2020"><a href="#2020" class="headerlink" title="2020-"></a><strong>2020-</strong></h4><p>2020年余额100%，空白交给我填补。</p>
<p>留下遗憾是必然的，只不过希望自己大胆地去追寻。Flag慢慢竖起来，倒下无所谓。</p>
<p>我希望在2020年把人生的里程碑一个一个拿下，去尝试去摸索去拥抱。</p>
<p>2019的词语是自由，2020的词语是探索。</p>
<p>很套路的结尾：你好，2020.</p>
<p>写于2020年1月1日</p>
]]></content>
  </entry>
  <entry>
    <title>Welcome to my World</title>
    <url>/2020/03/21/hello-world/</url>
    <content><![CDATA[<p>你好你好！</p>
<p>这是我第一次动手搭建自己的博客，希望能在这里把一些有趣的事情分享给大家。有的人可能觉得，程序员应该写技术博客呀，但是程序员也是有感情的，还有的程序员喜欢看书喜欢拉小提琴（虽然很久不练习了），也喜欢听音乐看电影之类的，并且很乐于把他们分享给大家。总之，我的地盘我做主，welcome to my world !</p>
<p><img src="/21/hello-world/sakura.jpg" alt></p>
<p><img src="../images/sakura.jpg" alt></p>
<a id="more"></a>



]]></content>
  </entry>
</search>
