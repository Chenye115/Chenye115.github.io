<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>汇编</title>
    <url>/2020/12/26/%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>MASM 汇编器 链接器</p>
<p> 32 位保护模式   64 位模式   16 位实地址模式 </p>
<p> 所有 x86 处理器都理解共同的机器语言 </p>
<p> 汇编语言不是可移植的，因为它是为特定处理器系列设计的   每一种都基于一个处理器系列 </p>
<p> 由于汇编语言占用内存少，因此它是编写嵌入式程序的理想工具</p>
<p> 汇编语言可以用于优化应用程序的部分代码来提升速度，或用于访问计算机硬件 </p>
<p> 计算机使用的是字符集，将字符映射为整数 , 在字符模式（如 MS-DOS）下运行时，IBM 兼容微机使用的还是 ASCII（读为“askey”）字符集 .</p>
<p> ANSI   Unicode  </p>
<ul>
<li><p>UTF-8 用于 HTML，与 ASCII 有相同的字节数值。</p>
</li>
<li><p>UTF-16 用于节约使用内存与高效访问字符相互平衡的环境中。比如，Microsoft Windows 近期版本使用了 UTF-16，其中的每个字符都有一个 16 位的编码。</p>
</li>
<li><p>UTF-32 用于不考虑空间，但需要固定宽度字符的环境中。每个字符都有一个 32 位的编码。</p>
<p>32 位 x86 处理器  包括了 Intel IA-32 系列中的成员和所有 32 位 AMD 处理器 </p>
</li>
</ul>
<p>==x86 处理器==</p>
<p>有三个主要的操作模式：保护模式、实地址模式和系统管理模式；以及一个子模式：虚拟 8086 (virtual-8086) 模式，这是保护模式的特殊情况。 </p>
<a id="more"></a>

<p> 基本程序执行寄存器（basic program execution registers）。8 个通用寄存器，6 个段寄存器，一个处理器状态标志寄存器（EFLAGS），和一 个指令指针寄存器（EIP）</p>
<p> 指令指针（EIP）寄存器中包含下一条将要执行指令的地址。某些机器指令能控制 EIP，使得程序分支转向到一个新位置。 </p>
<p> <img src="http://c.biancheng.net/uploads/allimg/190427/4-1Z42G35644562.gif" alt="基本程序执行寄存器">  </p>
<table>
<thead>
<tr>
<th>32 位</th>
<th>16 位</th>
<th>8 位（高）</th>
<th>8 位（低）</th>
</tr>
</thead>
<tbody><tr>
<td>EAX</td>
<td>AX</td>
<td>AH</td>
<td>AL</td>
</tr>
<tr>
<td>EBX</td>
<td>BX</td>
<td>BH</td>
<td>BL</td>
</tr>
<tr>
<td>ECX</td>
<td>CX</td>
<td>CH</td>
<td>CL</td>
</tr>
<tr>
<td>EDX</td>
<td>DX</td>
<td>DH</td>
<td>DL</td>
</tr>
</tbody></table>
<p>特殊用法其他通用寄存器只能用 32 位或 16 位名称来访问，如下表所示：</p>
<table>
<thead>
<tr>
<th>32 位</th>
<th>16 位</th>
<th>32 位</th>
<th>16 位</th>
</tr>
</thead>
<tbody><tr>
<td>ESI</td>
<td>SI</td>
<td>EBP</td>
<td>BP</td>
</tr>
<tr>
<td>EDI</td>
<td>DI</td>
<td>ESP</td>
<td>SP</td>
</tr>
</tbody></table>
<h4 id="特殊用法"><a href="#特殊用法" class="headerlink" title="特殊用法"></a>特殊用法</h4><p>某些通用寄存器有==特殊用法==：</p>
<ul>
<li><p>乘除指令默认使用EAX。它常常被称为扩展累加器（extended accumulator）寄存器。</p>
</li>
<li><p>CPU 默认使用 ECX 为循环计数器。</p>
</li>
<li><p>ESP 用于寻址堆栈（一种系统内存结构）数据。它极少用于一般算术运算和数据传输，通常被称为扩展堆栈指针（extended stack pointer）寄存器。</p>
</li>
<li><p>ESI 和 EDI 用于高速存储器传输指令，有时也被称为扩展源变址（extended source index）寄存器和扩展目的变址（extended destination index）寄存器。</p>
</li>
<li><p>高级语言通过 EBP 来引用堆栈中的函数参数和局部变量。除了高级编程，它不用于一般算术运算和数据传输。它常常被称为扩展帧指针（extended frame pointer）寄存器。</p>
<p>浮点单元（FPU, floating-point unit）执行高速浮点算术运算。之前为了这个目的，需要一个独立的协处理器芯片。从 Intel486 处理器开始，FPU 已经集成到主处理器芯片上。 </p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/4-1Z42G4034NE.gif" alt="浮点单元寄存器"> </p>
<p>x86 处理器按照前面讨论的基本操作模式来管理内存。保护模式是最可靠、最强大的，但是它对应用程序直接访问系统硬件有着严格的限制。 </p>
<p>在实地址模式中，只能寻址 1MB 内存，地址从 00000H 到 FFFFFH。处理器一次只能运行一个程序，但是可以暂时中断程序来处理来自外围设备的请求 (中断处理)</p>
</li>
</ul>
<p>在保护模式中，处理器可以同时运行多个程序，它为每个进程（运行中的程序）分配总共 4GB 的内存。  每个程序都分配有自己的保留内存区域，程序之间禁止意外访问其他程序的代码和数据。 </p>
<p> ==x86-64 指令集的 64 位处理器==</p>
<p> 包括 Intel 64 和 AMD64 处理器系列 ，</p>
<p> 1) 向后兼容 x86 指令集。</p>
<p>2) 地址长度为 64 位，虚拟地址空间为 2 64 字节。按照当前芯片的实现情况，只能使用地址的低 48 位。</p>
<p>3) 可以使用 64 位通用寄存器，允许指令具有 64 位整数操作数。</p>
<p>4) 比 x86 多了 8 个通用寄存器。</p>
<p>5) 物理地址为 48 位，支持高达 256TB 的 RAM。 </p>
<p><code>另一个为人所知的 64 位 Intel 架构是 IA-64，后来被称为 Itanium。 IA-64 指令集与 x86 和 x86-64 完全不同，Itanium 处理器通常用于高性能数据库和网络服务器。</code></p>
]]></content>
  </entry>
  <entry>
    <title>现有的DoS防御技术整理</title>
    <url>/2020/12/26/%E7%8E%B0%E6%9C%89%E7%9A%84DoS%E9%98%B2%E5%BE%A1%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h3 id="现有的DoS-DDoS-防御技术整理"><a href="#现有的DoS-DDoS-防御技术整理" class="headerlink" title="现有的DoS(DDoS)防御技术整理"></a>现有的DoS(DDoS)防御技术整理</h3><p><a href="mailto:chenye0920@qq.com">chenye0920@qq.com</a> 2020年12月23日</p>
<h4 id="DoS产生的主要原因："><a href="#DoS产生的主要原因：" class="headerlink" title="DoS产生的主要原因："></a>DoS产生的主要原因：</h4><ol>
<li>系统存在耗资源的操作，包括内存和 CPU 以及带宽</li>
<li>使用共享资源的操作 ，容易导致死锁</li>
<li>缓冲区溢出  </li>
<li>内存泄漏</li>
<li>不正确的缓存机制 </li>
<li>服务使用的工具或者系统的配置不当 </li>
<li>存在注入问题，如 SQL 注入 ，命令行注入等</li>
<li>协议级别的攻击：SYN flood，ICMP攻击， 这些攻击都有一些特征，可以通过防火墙定制规则过滤这些包，  升级使用最新版的协议 </li>
</ol>
<a id="more"></a>



<h4 id="抵抗DoS攻击"><a href="#抵抗DoS攻击" class="headerlink" title="抵抗DoS攻击"></a>抵抗DoS攻击</h4><p> 通过对 DoS /DDoS的原理和特点分析 , 可以看 出对 DoS /DDoS的防范是很困难的 , 除了互联网的 开放性外 , DoS /DDoS 攻击手段其实也是一种合法 的访问请求 , 只是这种访问的强度远远超过服务器 可承受的程度而已。因此需要分析哪些请求是正常的用户访问 , 哪些是恶意的访问。</p>
<p>提高DDoS攻击检测率：基于BO神经网络的方法</p>
<p>预防： </p>
<ol>
<li>及时安装系统补丁程序和定时升级 , 并经常使用漏洞扫描软件对内部网络进行检查，提高系统安全性能 </li>
<li>在主要 ISP的核心路由器上安装防火墙 </li>
</ol>
<p>鉴别与过滤：</p>
<ol>
<li>套实时鉴别系统 , 对服务器所在的网段进行实时监控 , 以便及时发现攻击并采取必要的措施 。 例如通信流量突然持续增大 , 出现特大型的UDP或ICMP数据包, 以及短时间内集中出现超量的相同数据包等。 </li>
<li>通常采用的过滤策略有: 同时采用的输入分组过滤 , 本地攻击检测 , 基于路由的分组过滤等 </li>
</ol>
<h4 id="缓减DoS攻击"><a href="#缓减DoS攻击" class="headerlink" title="缓减DoS攻击"></a>缓减DoS攻击</h4><h5 id="流量过滤"><a href="#流量过滤" class="headerlink" title="流量过滤"></a>流量过滤</h5><p>流量过滤主要是对服务端接收到的流量进行IP、端口等过滤；</p>
<h5 id="服务端扩容"><a href="#服务端扩容" class="headerlink" title="服务端扩容"></a>服务端扩容</h5><p>主要是在检测出DDoS攻击后，为防止服务断线而采用的增加服务器节点个数等方式扩大对DDoS流量的容忍度。</p>
<h5 id="基于P2P的攻击减缓技术"><a href="#基于P2P的攻击减缓技术" class="headerlink" title="基于P2P的攻击减缓技术"></a>基于P2P的攻击减缓技术</h5><p>1、 隐藏减缓技术</p>
<p>基本思路是在用户(包括攻击者)与被保护服务器之间放置一个P2P网络作为隔离带，使攻击者无法找到实际服务器的真实位置，从而无法直接接触攻击目标。 </p>
<p>2、 漂移减缓技术 </p>
<p> 服务器在一个P2P网络内时间、位置上的非预测性移动，使 Dos试图攻击的目标位置飘忽不定，从而使攻击者难以锁定攻击目标。它建立在TCP迁移技术的基础上。TCP迁移技术可以无缝的将一个TCP连接从一个服务器上透明地移到另一个位置。位置漂移可以是物理的也可以是逻辑的，如采用动态修改服务器的IP地址。  </p>
<p>3、联盟减缓技术</p>
<p> 联盟减缓技术利用了P2P网络资源共享的特性。提供web服 务的ISP服务器通过P2P网络形成某种合作联盟，当一个ISP服务器被攻击时，将服务复制到联盟内的其他服务器上以保持服务的连续。  </p>
<h5 id="基于非P2P的攻击减缓技术"><a href="#基于非P2P的攻击减缓技术" class="headerlink" title="基于非P2P的攻击减缓技术"></a>基于非P2P的攻击减缓技术</h5><p>1、 客户难题</p>
<p>基本原理是：服务器在提供服务前要求客户端主机求解一个给出的题目，如一些加密／解密计算等，对不同的用户给出不同难度等级的题目，合法用户可能只需求解一个十分简单的问题，而对于可能是DoS攻击的主机给出一个需要消耗大量资源的难题以遏制攻击请求的流量。</p>
<p>2、   图灵测试</p>
<p>一种可用于区分用户为自然人或者为机器的一种人工智能技术。图灵测试攻击减缓技术的基本原理是：自然人对一些特殊的图像内容具有强大的、 快速的识别能力，而机器没有这种能力，Dos攻击者直接发出大量虚假请求的为傀儡主机，利用图灵测试可以有效的识别傀儡主机，减低Dos攻击效果。  </p>
<p>3、 QoS服务技术 </p>
<p> 各种资源预留协议、区分服务协议均可以作为 Dos攻击的可行对策，因为它们从资源控制使用的角度来保持重要用户服务的资源需求和优先权。对数据流进行有效的检测或分类，以区分服务的优先级别，进而在Dos攻击下做出各种响应。对于虚假源地址的Dos攻击，通过识别虚假的源地址，过滤 掉Dos攻击分组；对于使用真实源地址的Dos攻击分组，采用公平服务调度算法限制流量以丢弃攻击者的大部分攻击分组，减轻Dos攻击的作用。  </p>
<h5 id="基于改进DHCP协议的地址跳变方法"><a href="#基于改进DHCP协议的地址跳变方法" class="headerlink" title="基于改进DHCP协议的地址跳变方法"></a>基于改进DHCP协议的地址跳变方法</h5><p>这种方法增加了攻击者进行拒绝服务攻击的难度。通过构建动态、异构、不确定的信息系统，增加其多样性、随机性和动态性，提升攻击难度和代价，有效限制脆弱性暴露及被攻击的机会。</p>
<p> 地址跳变指通信双方按照既定协议伪随机地改变通信地址，实现网络主动防御。 改进后的地址跳变方案利用 DHCP协议保留字段，在不改变现有协议的基础上为同一主机同时分配多个地址，以满足地址跳变的多样性需求；基于现有 DNS协议建立客服双方的地址映射关系以及服务器固有地址与跳变地址的关联关系，在不改变服务器固有地址的情况下完成跳变通信，以满足地址跳变的随机性需求；利用基于动态时间弯曲距离 DTW的时间序列相似性度量算法检测网络异常并调整地址租用期，以满足地址跳变的动态性需求。</p>
<p>  在抗连通性 DoS 攻击方面，  设可用跳变地址数为m ，攻击数据包中包含当 前活动地址的数目为k , r 为攻击速率，k 的期望为 $E(k)=rT_{tol}/m$, 可见，m 越大，单位平均攻击强度越小；$T_{tol}$ 越小， 地址跳变越快，遭受持续攻击的概率越小。 </p>
<h5 id="基于代价的形式化分析方法"><a href="#基于代价的形式化分析方法" class="headerlink" title="基于代价的形式化分析方法"></a>基于代价的形式化分析方法</h5><p>适合对资源消耗型DoS攻击进行建模，该建模方法通过设置容忍关系，比较产生一个数据和验证这个数据所要花费的代价大小，判断协议是否存在DoS攻击；基于这个模型可以指出，JFK协议能够抵抗DoS攻击，而STS协议不具有抗DoS攻击能力 </p>
<h5 id="基于数据挖掘的抗DoS攻击模型（DMADM）"><a href="#基于数据挖掘的抗DoS攻击模型（DMADM）" class="headerlink" title="基于数据挖掘的抗DoS攻击模型（DMADM）"></a>基于数据挖掘的抗DoS攻击模型（DMADM）</h5><p> 采取数据挖掘算法，结合BP网络算法，建立的一个基于数据挖掘的抗DoS攻击的防范模型。（Data  Mining-Based  Anti-DoS  Attack Model），本模型可以从网络中抓取网络流量信息和数据包信息，然后根据知识库中已经建立的模型和训练好的流量趋势曲线，对网络信息进行判别，看是否有攻击产生。将感应模块抓取的网络连接信息利用关联规则算法、序列模式算法挖掘出关联模型和序列模式模型，作为判断攻击是否发生的重要方法。针对某些特征比较明显的攻击，本模型用端口挖掘模块和 IP 挖掘模块进行直接处理，并不对其进行过深的分析，一定程序上避免了模型本身遭受 DoS 攻击。</p>
<p>该模型由 8 个模块组成，它们分别是：感应模块、开采模块、分析模块、IP 挖掘模块、端口挖掘模块、控制模块、执行模块。在实验中，其抗 DoS攻击效果比较显著。</p>
<p> DoS Mitigation Using Proof Of Work  </p>
<h4 id="对论文-DoS-Mitigation-Using-Proof-Of-Work-的理解"><a href="#对论文-DoS-Mitigation-Using-Proof-Of-Work-的理解" class="headerlink" title="对论文 DoS Mitigation Using Proof Of Work  的理解"></a>对论文 DoS Mitigation Using Proof Of Work  的理解</h4><p>对于论文中提到的通过PoW证明来缓解DoS攻击的方法，大致属于上述分类中的基于非P2P的攻击减缓技术中的客户难题。服务器在提供服务前要求客户端主机求解一个给出的题目，也就是Hashcash的求解难题。对客户机解决问题的时间进行评估，以验证是正常的请求还是DoS攻击，这是因为DoS攻击通常通过僵尸网络中设备发送请求，这些设备通常是算力低下的物联网智能家居等设备，解决问题的时间明显高于真实访问的客户机。</p>
<p>目前对论文中涉及的实验有一定的了解，由于时间以及任务分配的关系，主要是查阅了有关DoS攻击的资料并整理。对论文以及实验的其他细节部分还需要进一步研读。</p>
]]></content>
  </entry>
  <entry>
    <title>小说</title>
    <url>/2020/08/06/%E5%B0%8F%E8%AF%B4/</url>
    <content><![CDATA[<h1 id="小说"><a href="#小说" class="headerlink" title="小说"></a>小说</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>1</p>
<p>​    赵年心里有一些忐忑。今天是开学的第一天，按道理来说开学第一天应该早点儿去挑一个好一点的座位，不过想到家里离学校就几步路，又想到班上都是陌生的面孔，去早了也只能一个人尴尬地坐着–赵年知道自己不是一个很快就能和陌生的孩子们熟络起来的人，所以选择了在班主任通知的正常上课时间前十分钟走出了家门。要是不磨蹭的话，七八分钟是肯定能走到教室的。</p>
<a id="more"></a>

<p>​    昨天赵年和爸爸去报名的时候已经找过教室了，很好找的，就在教学楼的一楼，走进大门的左手位置就是初一二班的教室。按道理是上午去报名的，可是爸爸说他和班主任认识–也就普通的关系，仅仅知道这个老师的名字吧，说是要下午单独带赵年去找班主任，顺便聊几句。赵年也没有乐不乐意的，反正也不是小孩子了，爸爸大致要和班主任说什么也能猜到。唠唠教育机关的体制啦，聊聊在彼此在哪哪见过啦，最后落到请老师要多多管教自家的孩子啦。赵年觉得这些话并没有什么作用，无非就是客套，和老师说要多关照自家小孩的家长也不少，老师当然是满口答应下来咯。赵年想着上午报名肯定人特别多，而且自个儿得自己去，听起来又麻烦又尬，爸妈上午都要上班，于是满口答应了老爸。</p>
<p>​    可是上午报名的人嘻嘻笑笑地从自家楼下走过，从阳台上往下看尽收眼底。赵年心里痒痒了，呆在家里也没有事情，不如就去学校里看看。反正大概…也就看看分班的情况，看看有没有自己的小学时代的老同学，嗯。于是赵年换了一身干净的衣服，出门了。</p>
<p>​    县城里有十来所中学，都是公办的。其中明德中学的建校时间最晚。实际上明德中学是县实验学校的初中部独立出来的，新迁到现在这里，又另外立了一个校长。但是地处县城的中心，地理位置是其他中学没法比的，所以建校以来好的老师都托关系往明德中学调，住在县城里的孩子自然而然的会选择明德中学，因此学生质量也很好。听说自打建校以来，县里的中考中考状元就没有跑过，在教学成绩上持续碾压其他学校，在县城里来讲可以相对来说是一所超级中学。</p>
<p>​    学校里果然人超多，都是今天新生来开学的，家长孩子在公示栏前挤成蚂蚁窝，公示栏上应该贴着分班的表。赵年在人群后面观望了一会儿，不停地观察身边的人，有一些在小学的时候楼道里经常碰见的面孔，但是并没有发现曾经要好的朋友。欸，还是要自己挤进去看啊。赵年想着，不太情愿地钻进了人堆里。</p>
<p>​    这一届的学生一共分了八个班，每个班都有六十多号人。名字还挺好找的，每个班都按照名字的首字母排序。赵年在一班没有自己的名字，但很快在二班的末尾就找到了。又在二班的名单里仔仔细细地从前往后看了一遍，同在二班比较熟悉的还有谢希，之前通过三年学，六年级分班的时候分走了，还有六年级同班的高宇轩，吴已龙–这俩人在之前同学的时候就没有什么交集–哦还有一个叫陈思雨的女生，是幼儿园时代的玩伴，后来搬家了就不在一起玩了，小学也同过几年的学。</p>
<p>​    赵年想着，还不算太糟糕，至少有谢希这样儿时熟悉的小伙伴。都好不容易挤到了公示栏的第一排，赵年想干脆就找一下其他好朋友的班级。大致看了一遍，刘小峰和陈曦还有边文军在八班，刘思源在七班，何西也在七班，其他的记不大清楚了。身后的人不停的往前挤，九月的开头还是很热的，赵年没有再发现什么有价值的信息，就赶紧从公告栏下钻到背面去了。下午还得来一趟，就懒得去找教室了，赵年这么想，就赶紧回家了。</p>
<p>​    现在，赵年已经看到了教室门口挂着的初一二班的牌子，门敞开着，能听到屋里传出来嗡嗡嗡的说话声。赵年叹了口气，嗓子眼儿有点儿堵。</p>
<p>​    初中的生活就要这样开始了么。    </p>
<p>2</p>
<p>​    前几排好像都坐满了人，似乎早就互相认识的同学并不少，叽叽喳喳地在说话。中间几排还有几个落单的座儿，可是周围的人赵年都没有见过，而且看上去都不是讨人喜欢的类型。一边找着座位，一边打量这些将要共处好几年的新同学，不觉已经来到了最后一排，站在教室最后往前看。</p>
<p>​    还是没有合适的座位啊。赵年心想。</p>
<p>​    “嘿，年哥！”最后一排的一个个子挺高的男生回过头来冲着赵年笑。“赵年你没找到座儿你就跟我一起分一条凳子得了。”原来是高宇轩，他不爱和陌生人说话，看上去周边也没有认识的同学。赵年和他也就一般的同学关系，不过眼下反正也找不到合适的座位了，又快要打铃了，干脆就凑一凑好了。</p>
<p>​    “老高那我不客气了。”赵年绷着的脸终于咧嘴一笑，把空瘪的书包塞在他的桌子里，压在他书包上面。</p>
<p>​    赵年和高宇轩各自占了半边凳子。赵年左边的同学正在看一本小说，老高右边两个同学都用手呆呆地坐着打量全班，默不作声。</p>
<p>​    “以后我就指望年哥罩着。”老高好不容易找到了一个熟人，左手勾在赵年的肩上，开始扯淡。</p>
<p>​    “开什么玩笑，我啥时候能罩着你了。”应付这种扯淡，赵年也是轻车熟路，“我给你做小弟要不要。”说着开始打量周围。</p>
<p>​    他欣喜地发现谢希就坐在他的左前方，刚刚一直没有发现。</p>
<p>​    “谢希！”</p>
<p>​    谢希正隔着过道和对面的同学嬉笑，看起来挺熟络的，应该是之前的同学吧。听到自己名字，谢希回过头来看了一眼：“赵年啊，你终于来了。”又转过去和对面的同学说了起来。过道对面那同学也看了赵年一眼，挺白净的小伙子，相比之下谢希又黑又糙。他搞了一个叫不上名来的发型–在这个年纪的男生，不是平头就是寸头，留其他种类发型的真是稀罕。</p>
<p>​    铃声响了，按道理第一天上课都是班主任说道说道，但是班主任并没有马上出现，教室里嗡嗡嗡的声音也没有马上停止。于是赵年拉着老高攀谈。老高是昨天上午就自己来报名了，听他讲述，当时在教室里的家长学生乱成一团，他排了好久才报上名。本来他来得也不算晚的，但是总是被一些家长插队，等他搞定了都该回家吃中午饭了。</p>
<p>​    还好老爸下午带我直接去班主任的办公室了。赵年心里暗笑。</p>
<p>​    班主任叫做袁辉，年纪比赵年老爸要大一些，比老爸要高而且强壮，两鬓有些花白，肉眼可见的鱼尾纹。昨天下午在办公室的时候，他一直和气地笑，说啥都要眯着眼先笑一会儿。老爱抽烟，赵年和老爸在办公室没多久，他已经抽掉两支了，可能是因为抽烟过度，嗓子有点沙哑。赵年向来受不了烟味，眼下老爸也点上了一支陪着班主任一起抽，于是在办公室里随便走走翻翻，逃避这四处发散的烟味。</p>
<p>​    不知道老爸和袁辉都说了些什么，十来分钟后老爸喊赵年准备回去。赵年“嗯”了一声走向办公室门口，班主任起身把老爸送到门外，俩人像是惺惺相惜的老朋友，尽管真正认识才没几分钟。</p>
<p>​    临走时老爸拍了拍赵年的肩膀，也不知对着谁说：”以后年年就拜托你了。”</p>
<p>​    班主任又呵呵地笑了，从上到下把赵年打量了一番，像是在验货：“小伙子有出息啊。”</p>
<p>​    赵年心里想着这你也能看出有出息吗，这是什么玄学，嘴上却老老实实地嗯了一声，说了声：“谢谢老师。”然后就和老爸回家了。</p>
<p>​    正回忆着昨天下午在办公室见到袁辉的事儿，教室里突然安静下来，班主任走了进来。</p>
<p>3</p>
<p>​    班主任把胳膊下夹的一堆花花绿绿的纸发下去，大概就是印的一些时间安排，安全教育，责任说明之类的东西。确保每个同学都拿到后，特别提醒了有一张告家长书要拿回去家长签字然后第二天把回执交上去。</p>
<p>​    处理完这些，才在黑板上写下了自己的名字和电话号码。袁辉告诉我们他是教数学的，说到这他又想了想，把其他主课老师的电话号码留在黑帮上，下面的同学紧张地记在各自的小本或者纸条上。袁辉干这些的时候都没有笑过，板着脸，一点儿也不像昨天在办公室里见到的那个乐呵呵的笑面人，加上他沙沙的嗓音，像是一个恶人，严肃冷酷。</p>
<p>​    然后他喊后两排高一点壮一点的男生去隔壁空教室搬书–老高肯定是要去的，否则白白浪费这大个劳动力了。谢希和过道对面那个男生也站了起来。赵年也起身了，反正呆在教室里也不能干啥，还没有人一起说话。</p>
<p>​    袁辉领着十几号男生来到了二楼的空教室，教室里按着班级摆好了一摞摞的书。管理这些书的老师让我们在门外等一等，里边还有一个班级的同学正在把书往外运。这时袁辉的电话响了–我想起来他好像是学校哪儿哪儿的主任–然后进了空教室和管书的人说了几句。出来的时候跟我们大家说：“我有点儿事，你们待会儿把书搬到教室就直接发下去，本子先别发，我马上就回来。那个谁…”他往我们的脸上一个个扫过，不知道在找谁。</p>
<p>​    “那个谁，赵…赵年是吧，待会儿组织一下大家把书发下去。里面的老师会告诉你们怎么发。我马上就回来。”他强调了一下“马上”，“你们进去吧。”</p>
<p>​    “啊…老师，我吗？”突然被点，赵年有点诧异，一脸迷茫。为什么是我，开学第一天就这么放心地交给学生吗，真是没见过这样的老班。赵年心想着，嘴上却又是另一套了：“哦哦，好的。”</p>
<p>​    管书的老师出来催了：“二班的同学进来！”我们就鱼贯而入，一人抱了一摞书往自己教室走。赵年找管书的老师问了下怎么发的事，当他也抱了一摞书走出空教室的时候，袁辉已经不见了。</p>
<p>​    回到教室，书已经摆在讲台的地上了，不过搬书的同学都回到自己的座位上，本来还打算请他们发一下的。讲台底下依旧是嗡嗡嗡的。赵年把自己搬的书押在讲台上，大声说了一句：“现在发书了！”对赵年来说，吼这么一句并不是什么难事，毕竟是小学当了五年的班长。不少同学抬头看了一眼，底下依旧是嗡嗡嗡的。</p>
<p>​    没办法。</p>
<p>​    “谢希，高宇轩，帮忙上来发下书。”老高一直盯着我，赵年一喊就苦笑着走上了讲台，倒没有拒绝的意思。谢希还在和那个男生说话。</p>
<p>​    ”谢希，谢希！上来发书！”赵年提高了嗓门。这个比终于听见了，跟那个男生说了一句，一脸堆笑地走上讲台。那个男生也起身了，走到赵年面前说也一起帮忙发下书。赵年点了点头，告诉这三人从哪儿发起，不要发串了之类的。赵年自己也抱了一摞数学书，从第一大组的第一排开始发起。</p>
<p>​    才发了几本，赵年听到背后有人在喊他。“赵年，赵年！先给我一本好不好！”</p>
<p>​    赵年转过身，原来是陈思雨，小时候的玩伴。因为各自的老爸是同事，两家的孩子年龄又一样，而且住的近，两家的小孩就一起长大，小学六年级分班之前还一直是同班同学。不过六年级不同班，一年没有说过话了。</p>
<p>​    赵年觉得，陈思雨和五年级的时候没有什么区别，就是长高了不少，而且比之前成熟了一些…尤其指的是身体。先前那个用来矫正斜视的遮掉一只眼睛的眼镜也换掉了，剪了一个齐耳的短发。</p>
<p>​    ”不行，我发完第一大组再给你。”</p>
<p>​    “赵年你先给我一本嘛。”</p>
<p>​    ”我马上就发到你这儿了，等一下。”</p>
<p>​    “好吧，小气…”不过陈思雨还是把后面几个字咽下去了。</p>
<p>​    赵年一边发着书一边趁此机会仔细打量班上的同学们。有一个黑黑的小个子自己默默地玩着一把小刀，看起来是一个危险人物；一个脸色黄黄的小男生在看一本小说集，那种小说集赵年也看过，没什么营养；有俩女生发育特别超前，块头比赵年还大–赵年在男生中已经是中等偏上了，这让赵年想起六年级的时候被班上的大块头女生追着打；发书给三个穿紧身衬衫的男生时赵年听到了一堆脏话；赵年也没有忘记注意留心班上漂亮的女孩子–老高刚刚说这是男生的本性，班上确实有几个一眼就觉得好看的女孩子。赵年特意留心的第一大组中间靠墙的那个女生，她扎了一个马尾，头发又黑又密，眼睛大大的，眼角略微往上翘–递给她书的时候，女孩子对赵年轻轻说了一声谢谢，怪好听的。</p>
<p>​    还没有发完书，袁辉就回来了，站在教室门口看我们几个发书。</p>
<p>​    发完书，上午班主任就让我们自己看看新书，他在教室里转悠，有时候俯下身子小声跟个别同学说话，偶尔打着嗓门跟全班同学说什么，赵年记不清了，只是和老高一起看书。赵年发现中学的语文课本挺好看的。</p>
<p>​    上午剩下的时间一会儿就过去了。放学了有几个同学在讲台上找班主任说什么事情，赵年看左前方谢希和那个男生已经走了，就打算自己回去。走出教室前门的时候，陈思雨正在跟袁辉讲话–赵年并不关心他俩说啥，跟袁辉说了声：“老师再见。”径直往外走。</p>
<p>​    谁知刚走出门，身后沙哑的男中音就把赵年叫住了：“赵年，你等一下。“</p>
<p>​    </p>
<p>4</p>
<p>​    中午吃饭的时候，赵年妈妈问起今天在学校的事情。</p>
<p>​    “挺好的，就是…”赵年还在咽饭，囫囵地答了一句，“就是放学的时候，袁老师说，让我考虑下当我们班班长。”</p>
<p>​    老爸说：”我昨天下午跟你们袁老师说了，说你小学当了好几年的班长，希望他多培养。估计反正也是临时的，老师同学现在对班上的人还不太了解，年年你就先当着呗。“</p>
<p>​    ”我小学的时候班长跟当了没当一样啊，这有什么，好像每天啥也不用干就行了。管纪律的时候也没几个人会听我的。“赵年感觉自己被包办了，拿出一串事实。</p>
<p>​    “那你自己跟袁老师说一下，最好还是先当着吧。”</p>
<p>​    “嗯。”</p>
<p>​    赵年继续扒自己的饭，确实，他不想再当班长了，小时候也是妈妈去找班主任说的，她和他的小学班主任是关系不错的朋友。小学的时候，虽然当班长不用干什么，只是偶尔去办公室找下老师，班上某某和某某又打架了，领着老师一起去教室–不过通常只有打的很凶赵年才会这么做。当班长就多少有点儿责任，听起来就有些麻烦，有些不确定的因素。而且班长这一个头衔赵年已经挂了五年，从二年级到六年级，都听腻了。</p>
<p>​    吃完饭，赵年回到自己的房间里，把今天上午领来的新书一本一本地从书包里拿出来，从大到小码在书桌上，把书脊和书的底部对齐。数学，语文在上边，接下来是地理，历史，物理，在接下来是生物，思想品德，英语–英语书好厚一本，理所当然地放在最下面。</p>
<p>​    啊，终于我也是一名初中生了。赵年心里想，有点儿爽爽的感觉。还记得五年级开学前的一天，赵年站在床上，跟妈妈说，你看我像不像一个高年级的同学，带着自豪的语气。眼前一堆带着墨香的新书，头一回除了数学语文英语还有其他科目的课本。把课本一一写上自己的班级姓名–赵年 初一二班–再把写好名字的新书再重新摞成整整齐齐的一叠，书脊对书脊，就像是一种仪式。</p>
<p>​    我也是一名初中生了啊。赵年又美滋滋了一遍，才去睡觉–这是保持了六年的习惯。</p>
<p>​    下午赵年提前来到了学校，原因是不想和老高再挤一条凳子了。去的时候，谢希已经到了，旁边刚好有两个座位，赵年就坐在他的旁边。老高依旧坐在最后一排，看来他是喜欢坐在那，前排有很多空的位子。后来稍晚来一些的白昊做了另外一个座位，就是那个上午跟谢希一起说话的那个白白净净的男生。没想到他的名字里还真有一个白字，那为什么谢希的名字里没有一个黑字呢？赵年觉得有些好笑。白昊是谢希六年级的同学。这仨坐成一排，赵年坐在中间，没一会儿就跟白昊熟络了。</p>
<p>​    第一节课袁辉让大家自己看看书，然后又出去了。教室里比上午发书的时候要安静许多。赵年实际上在和谢希和白昊一起说话。袁辉不一会就回来了，跟上午一样在教室里转悠。赵年不想和他对视，一来是他的注意力一不在他们这一块，赵年就逮着机会和两个同桌说话，二来是有自己的原因，不想和老班打个照面好让他想起选定班长的事情。</p>
<p>​    可是赵年还是低估了袁辉的记忆。袁辉第二节课就把班委给定下来了。赵年至今忘了自己是怎么当上班长的，按道理来说，赵年的心里是抗拒的，中午已经打好注意要一口拒绝，当一条自由自在的活鱼，可是实际上赵年成了明德中学2012届初一二班的第一任班长。其中的过程大概就是，袁辉简单说了几句班上的同学暂时都互相不了解，班委暂时由他来推荐，只是暂时担任之类的话。然后赵年就听到他说，我们班暂时由赵年同学来担任班长，大家有没有什么意见–随后就是掌声–赵年还没搞懂发生了什么，正和谢希和白昊说这是不是搞错了，袁辉就让他站起来，好让大家认识一下他们的新班长。</p>
<p>​    赵年站起来的时候脸上写着明显的茫然，谢希和白昊笑得异常开心的样子。班上大多数同学都往赵年这儿看，戴眼镜的不戴眼镜的，一脸冷酷的和面带笑容的，目光一起投向赵年，看的赵年心慌慌的，咽了一口口水。</p>
<p>​    陈思雨转过来笑着给了赵年一个大拇指。</p>
<p>​    坐下的时候，白昊给了赵年一拳：“牛啊。”</p>
<p>​    赵年感觉方方的。什么啊，又当上班长了。</p>
<p>5</p>
<p>​    开学的头两天袁辉都没有提排座位的事情，他似乎学校那边的事儿贼多。几门课程都陆陆续续开始了，除了体育美术音乐之类的副课。二班的数学老师就是袁辉，别看他平时在班上讲话的时候一脸无情，讲起课来十分有激情，在讲台上大步流星，声音高昂饱满。不愧是男的数学老师，赵年心中暗暗咂舌。小学老师绝大多数都是女的，讲起课来软绵绵的没有什么波澜起伏–虽然说女老师都有一个可怕之处，那就是扇起耳光来绝不手软，向来心狠手辣，赵年也不是什么很乖的学生，曾不走运地体验过几次。小学也不是没有男老师，但赵年小学生涯的唯一一个教主课的男老师的英语教学水平实在是糟糕，上课纪律一塌糊涂，下了课就不见了踪影，似乎教书是他的副业，在少年宫教羽毛球才是他的主业和爱好。赵年觉得自己小学升初中的考试里，得分还没有总分的一半，和自己的英语老师有很大的关系。</p>
<p>​    语文老师也是男的，叫做彭林宁，个子不高，双目却是炯炯有神。赵年才13岁，在班上算是比较高的同学，身高已经和彭林宁差不多了。同时他也是六班的班主任，赵年在六班并没有很熟的同学，就无从知道彭林宁作为班主任在自己班上是一个什么样的狠角色，但是起码在二班上课的时候，彭林宁倒是看上去和蔼可亲。英语老师是女的，这让赵年还是很欣慰的，小学时候那个长得像体育老师的英语老师他已经不想再见到了。英语老师叫做王雨欣，当然啦她让班上的同学叫她Miss Wang就好了。小学的男英语老师叫Mr. Wang，这应该是巧合，赵年觉得两者并没有什么亲戚关系，因为Miss Wang的声音温柔优雅，听她讲英文就像是在听英文电影的台词。Miss Wang第一天上课的时候让班上每一个同学随便说点什么英语单词，说是看看同学们的发音如何。她挨个挨个凑近听每一个同学的发音的时候，赵年觉得她温柔极了，产生了莫名的好感。</p>
<p>​    其他的老师在前几天的课里大都是走个过场，赵年只是记得他们的历史老师是他的邻居。</p>
<p>​    开头几天座位基本上固定下来了，同学们就默认按着开学第一天下午的样子坐，而且都和附近的同学混的比较熟了。这就导致了赵年压根就没怎么听过什么数学课和英语课以外的东西，因为尽管他已经固定在他和谢希白昊三人组合的左边，靠着墙，谢希和白昊在美术思品历史这样老师不太管的课上讲话的时候他还是忍不住凑上去听，听着听着就想加入了。</p>
<p>​    在第三天的时候，他们仨就讨论过班上的女生哪几个好看的问题。这应该是每一个男生小团体里面经久不衰的话题，赵年非常乐意加入他们并发表自己的看法，每次说到这个，三人的眼睛就不停地在班上一遍又一遍地扫，不放过教室里的每一个旮旯犄角。男孩子在这方面的感觉基本上是一致的，其实有的女孩子赵年小学的时候就在廊道里见过。三个人没过几个课间就挑出了班上最好看的前几的女孩子，只是非得排个先后的话，三个人就出了不小的分歧。赵年觉得，发书那天给他说了声谢谢的那个叫做江玥倩的女孩子怎么说也得排进前五，但是谢希说她是他六年级时候的同学，可能是比较熟的原因，谢希觉得勉强排进前十就很不错了。就比如白昊觉得陈思雨–当时他还不知道她叫这个–至少也能排进前十，赵年和谢希都觉得太勉强。白昊在小学前几年不是在县城里的实验小学上的，只是六年级从其他地方转来，所以对这一届的学生不认识的更多了。</p>
<p>​    隔壁几个班都已经安排过座位了，上英语课的时候外面好多人在吵吵，三班正在换座位。可是袁辉似乎压根就没把这件事放在心上的样子，第一周就这么过去了。</p>
<p>6</p>
<p>​     周末回来的第一天下午班会课，袁辉终于着手准备排座位了。依次按照高矮，男生和女生各自排列，两支队伍差不多长，袁辉基本上按照排队的顺序指挥几个学生进去，男生和女生都穿插着，不一会儿外边站着的人就不剩下几个了，都是大高个。赵年也在里面，他发现班上最高的两个人竟然是俩女生，一个是雀斑脸扎着马尾，一个披着长发，一脸成熟的样子，和剩下的其他几个高个的男生嬉笑。</p>
<p>​    赵年被分配在倒数第三排，也就是第七排。好在并没有近视，所以看黑板并不费力。老高依旧是在最后一排，谢希和白昊被分开了，都在五六排的样子，可惜不在同一个大组，隔的很远。陈思雨和赵年同一个大组，不过在很靠前的位置。</p>
<p>​    赵年的新同桌叫做甘浩杰，不怎么说话，皮肤黑中带黄，有一点营养不良的感觉。除了刚搬到一起的时候互相交换了名字，以及传作业的时候问上一句以外，赵年都没有和他说过话。赵年倒没有觉得有什么郁闷的，反倒是不跟那俩货坐在一起之后，上课可以好好听讲了。而且反正大家没有这么拘束之后，同学们下了课都成小群地在教室外面玩儿。这就是教室在一楼的好处所在。</p>
<p>​    赵年所在的这个小集体中还有一个叫张龙辉的男生，又瘦又精壮，很自然地就成了“四人帮“的组合。在四人帮中，赵年和张龙辉差不多的高度，但是赵年没有那么瘦，虽然力气上可能比不过张龙辉，看上去还是赵年更加强壮一些。四个人下课了就凑在一起，那时候流行日本的热血动漫，《火影忍者》《海贼王》以及《死神》，下了课四个人就一起谈论动漫里的东西。说到兴起，还会模仿动漫中的人物，假装发动一套技能，上窜下跳地呼哧呼哧来几下。</p>
<p>​    </p>
]]></content>
  </entry>
  <entry>
    <title>Chapter 11 File System Implementation</title>
    <url>/2020/06/08/Chapter%2011%20File%20System%20Implementation/</url>
    <content><![CDATA[<h1 id="Chapter-11-File-System-Implementation"><a href="#Chapter-11-File-System-Implementation" class="headerlink" title="Chapter 11: File System Implementation"></a>Chapter 11: File System Implementation</h1><h2 id="File-System-Structure"><a href="#File-System-Structure" class="headerlink" title="File-System Structure"></a>File-System Structure</h2><p>File control block–storage structure consisting of information about a file. 文件控制块放在硬盘上，内存中存放的有文件控制块所包含的内容，文件存放在硬盘，硬盘上的存储是非易失的。</p>
<p>File structure: Logical storage unit  Collection of related information </p>
<p><strong>Layered File System：</strong></p>
<img src="/08/Chapter%2011%20File%20System%20Implementation/Users\kali_chenye\AppData\Roaming\Typora\typora-user-images\1591584216371.png" alt="1591584216371" style="zoom:50%;">

<p>应程程序进行系统调用：open read write… 执行IO语句</p>
<p>逻辑文件系统：目录 FCB 文件具体放在block（logic）上</p>
<p>文件组织模块：逻辑块映射到物理块 </p>
<p>基本文件系统：发出IO命令 磁盘地址</p>
<p>IO control：设备驱动</p>
<p>设备：以上都是软件层面，只有device是硬件  </p>
<p><strong>A Typical File Control Block</strong>: file permission, file dates, file owner,group,ACL ,file size ,file date blocks 抓住了文件控制块就抓住了文件</p>
<p>on-disk information: </p>
<p>boot control block,volume control block(每分区一个)  directory structure(每个文件系统一个)</p>
<p>FCB i-node UFS (这些信息放在磁盘上，文件加载后有些信息会放在内存中)</p>
<p><strong>In-Memory File System Structures</strong>：</p>
<p><img src="/08/Chapter%2011%20File%20System%20Implementation/C:%5CUsers%5Ckali_chenye%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1591585104441.png" alt="1591585104441"></p>
<p><img src="/08/Chapter%2011%20File%20System%20Implementation/C:%5CUsers%5Ckali_chenye%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1591585142146.png" alt="1591585142146"></p>
<a id="more"></a>

<h2 id="Directory-Implementation"><a href="#Directory-Implementation" class="headerlink" title="Directory Implementation"></a>Directory Implementation</h2><ul>
<li>Linear list of file names with pointer to the data blocks ：</li>
</ul>
<p>simple to program </p>
<p>time-consuming to execute</p>
<ul>
<li>Hash Table –linear list with hash data structure ：</li>
</ul>
<p>decreases directory search time </p>
<p>collisions –situations where two file names hash to the same location</p>
<img src="/08/Chapter%2011%20File%20System%20Implementation/Users\kali_chenye\AppData\Roaming\Typora\typora-user-images\1591585420213.png" alt="1591585420213" style="zoom:67%;">

<h2 id="Allocation-Methods"><a href="#Allocation-Methods" class="headerlink" title="Allocation Methods"></a>Allocation Methods</h2><h3 id="Contiguous-Allocation"><a href="#Contiguous-Allocation" class="headerlink" title="Contiguous Allocation"></a>Contiguous Allocation</h3><ul>
<li>Each file occupies a set of contiguous blocks on the disk.</li>
<li>Simple –only starting location (block #) and length (number of blocks) are required.</li>
<li>Random access.</li>
<li>Wasteful of space 外部碎片</li>
<li>Files cannot grow</li>
</ul>
<img src="/08/Chapter%2011%20File%20System%20Implementation/Users\kali_chenye\AppData\Roaming\Typora\typora-user-images\1591585602845.png" alt="1591585602845" style="zoom:50%;">

<h3 id="Extent-Based-Systems"><a href="#Extent-Based-Systems" class="headerlink" title="Extent-Based Systems"></a>Extent-Based Systems</h3><p>Extent-based file systems allocate disk blocks in <strong>extents.</strong> </p>
<p>An extent is a contiguous block of disks. Extents are allocated for file allocation. A file consists of one or more extents。 类似于存储管理中的分段segement</p>
<h3 id="Linked-Allocation"><a href="#Linked-Allocation" class="headerlink" title="Linked Allocation"></a>Linked Allocation</h3><p>Each file is a linked list of disk blocks: blocks may be scattered anywhere on the disk.</p>
<ul>
<li>Simple –need only starting address </li>
<li>Free-space management system –no waste of space </li>
<li>Files can grow </li>
<li>No random access </li>
<li>Each block contains a pointer, wasting space </li>
<li>Blocks scatter everywhere and a large number of disk seeks may be necessary </li>
<li>Reliability: what if a pointer is lost or damaged 不安全不可靠</li>
</ul>
<h3 id="File-Allocation-Table-FAT"><a href="#File-Allocation-Table-FAT" class="headerlink" title="File-Allocation Table FAT"></a>File-Allocation Table FAT</h3><p>FAT表在磁盘的最开始</p>
<img src="/08/Chapter%2011%20File%20System%20Implementation/Users\kali_chenye\AppData\Roaming\Typora\typora-user-images\1591586295483.png" alt="1591586295483" style="zoom:50%;">

<p>实现了随机访问，更加安全可靠</p>
<h3 id="Indexed-Allocation"><a href="#Indexed-Allocation" class="headerlink" title="Indexed Allocation"></a>Indexed Allocation</h3><p>Brings all pointers together into the index block</p>
<p>A file’s directory entry contains a pointer to its index. Hence, the index block of an indexed allocation plays the same role as the page table.</p>
<img src="/08/Chapter%2011%20File%20System%20Implementation/Users\kali_chenye\AppData\Roaming\Typora\typora-user-images\1591586502853.png" alt="1591586502853" style="zoom:50%;">

<ul>
<li>*<em>Random access *</em></li>
<li>无外部碎片</li>
<li>不是安全可靠的</li>
<li>文件的grow是有限的</li>
</ul>
<p>The indexed allocation suffers from wasted space. The index block may not be fully used </p>
<p>The number of entries of an index table determines the size of a file. To overcome this problem, we can have ：</p>
<ul>
<li>multiple index blocks, chain them into a linked-list </li>
<li>multiple index blocks, but make them a tree just like the indexed access method </li>
<li>A combination of both</li>
</ul>
<img src="/08/Chapter%2011%20File%20System%20Implementation/Users\kali_chenye\AppData\Roaming\Typora\typora-user-images\1591586700043.png" alt="1591586700043" style="zoom:50%;">

<p><img src="/08/Chapter%2011%20File%20System%20Implementation/C:%5CUsers%5Ckali_chenye%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1591587524372.png" alt="1591587524372"></p>
<p><img src="/08/Chapter%2011%20File%20System%20Implementation/C:%5CUsers%5Ckali_chenye%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1591587687829.png" alt="1591587687829"></p>
<p>4 128 84+2^16</p>
<h2 id="Free-Space-Management"><a href="#Free-Space-Management" class="headerlink" title="Free-Space Management"></a>Free-Space Management</h2><p>How do we keep track free blocks on a disk?  A free-list is maintained(维护).</p>
<p>When a new block is requested, we search this list to find one. </p>
<ul>
<li>Bit Vector </li>
<li>Linked List </li>
<li>Linked List + Grouping </li>
<li>Linked List+Address+Count</li>
</ul>
<p><strong>Linked Free Space List on Disk</strong>:</p>
<img src="/08/Chapter%2011%20File%20System%20Implementation/Users\kali_chenye\AppData\Roaming\Typora\typora-user-images\1591588592801.png" alt="1591588592801" style="zoom:50%;">

<p><strong>Link+Grouping:</strong></p>
<p>The first free block contains the addresses of n other free blocks. </p>
<p>For each group, the first n-1 blocks are actually free and the last (i.e., n-th) block contains the addresses of the next group. </p>
<p><strong>Link+Address counting:</strong></p>
<p>Blocks are often allocated and freed in groups</p>
<p>We can store the address of the first free block and the number of the following n free blocks.</p>
<h2 id="Efficiency-and-Performance"><a href="#Efficiency-and-Performance" class="headerlink" title="Efficiency and Performance"></a>Efficiency and Performance</h2><p>Efficiency dependent on: </p>
<ul>
<li>disk allocation and directory algorithms </li>
<li>types of data kept in file’s directory entry </li>
</ul>
<p>Performance:</p>
<ul>
<li>disk cache </li>
<li>free-behind and read-ahead  延后释放，提前读取</li>
<li>improve PC performance by dedicating section of memory as virtual disk, or RAM disk 提升硬件性能</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Chapter 8  Memory Management</title>
    <url>/2020/05/31/Chapter%208%20%20Memory%20Management/</url>
    <content><![CDATA[<h1 id="Chapter-8-Memory-Management"><a href="#Chapter-8-Memory-Management" class="headerlink" title="Chapter 8:  Memory Management"></a>Chapter 8:  Memory Management</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Program must be brought into memory and placed within a process for it to be run</p>
<h3 id="Base-and-Limit-Registers"><a href="#Base-and-Limit-Registers" class="headerlink" title="Base and Limit Registers"></a>Base and Limit Registers</h3><p>A pair of base and limit registers define the logical address space</p>
<h3 id="Multi-step-Processing-of-a-User-Program"><a href="#Multi-step-Processing-of-a-User-Program" class="headerlink" title="Multi-step Processing of a User Program"></a>Multi-step Processing of a User Program</h3><p><img src="/31/Chapter%208%20%20Memory%20Management/C:%5CUsers%5Ckali_chenye%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1589504830233.png" alt="1589504830233"></p>
<h3 id="Binding-of-Instructions-and-Data-to-Memory"><a href="#Binding-of-Instructions-and-Data-to-Memory" class="headerlink" title="Binding of Instructions and Data to Memory"></a>Binding of Instructions and Data to Memory</h3><p>Address binding of instructions and data to memory addresses can happen at three different stages</p>
<p><strong>Compile time</strong>:  If memory location known a priori, absolute code can be generated; must recompile code if starting location changes. </p>
<p><strong>Load time:</strong>  Must generate relocatable code if memory location is not known at compile time. </p>
<p><strong>Execution time</strong>:  Binding delayed until run time if the process can be moved during its execution from one memory segment to another.  Need hardware support for address maps</p>
<a id="more"></a>

<h3 id="Logical-vs-Physical-Address-Space"><a href="#Logical-vs-Physical-Address-Space" class="headerlink" title="Logical vs. Physical Address Space"></a>Logical vs. Physical Address Space</h3><ul>
<li><p>Logical address–generated by the CPU; also referred to as virtual address. </p>
</li>
<li><p>Physical address–address seen by the memory unit.</p>
</li>
</ul>
<p>Logical and physical addresses are the same in compile-time and load-time address-binding schemes </p>
<p>logical and physical addresses differ in execution time address-binding scheme</p>
<p>In this case, logical address is also referred to as virtual address. (Logical = Virtual in this course) MMU内存管理单元来决定虚拟地址到物理地址的转换 <strong>Memory-Management Unit</strong> </p>
<p>The user program deals with logical addresses; it never sees the real physical addresses.</p>
<h3 id="Dynamic-Loading"><a href="#Dynamic-Loading" class="headerlink" title="Dynamic Loading"></a>Dynamic Loading</h3><p>Better memory-space utilization; unused routine is never loaded</p>
<p>Useful when large amounts of code are needed to handle infrequently occurring cases</p>
<h3 id="Dynamic-Linking"><a href="#Dynamic-Linking" class="headerlink" title="Dynamic Linking"></a>Dynamic Linking</h3><p>比动态load更进一步 Both Linking and loading postponed until execution time. </p>
<p><strong>节省内存，灵活性</strong></p>
<p>When a routine is called, its stub is executed. The routine is loaded, the address of that routine replaces the stub, and executes the routine</p>
<p>Operating system needed to check <strong>if routine is in another process’ memory address</strong></p>
<p>Dynamic linking is particularly useful for libraries</p>
<h2 id="Swapping"><a href="#Swapping" class="headerlink" title="Swapping"></a>Swapping</h2><h2 id="Contiguous-Allocation"><a href="#Contiguous-Allocation" class="headerlink" title="Contiguous Allocation"></a>Contiguous Allocation</h2><p>如何分配给不同的进程使用 如何找到进程要访问的内存地址（寻址）</p>
<p><strong>Monoprogramming systems</strong> ：</p>
<ul>
<li>系统</li>
<li>用户</li>
</ul>
<p><strong>Multiprogramming systems：</strong></p>
<ul>
<li>Fixed partitions </li>
<li>variable partitions</li>
</ul>
<p><strong>Fixed partitions</strong>：</p>
<p>Memory is divided into n partitions. Partitioning can be done at the startup time and altered later on. <strong>Each partition may have a job queue. Or, all partitions share the same job queue</strong></p>
<p><img src="/31/Chapter%208%20%20Memory%20Management/C:%5CUsers%5Ckali_chenye%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1589508667796.png" alt="1589508667796"></p>
<p><strong>Variable Partitions ：</strong></p>
<p><strong><em>Hole</em></strong>–block of available memory–&gt;How to satisfy a request of size n from a list of free holes</p>
<ul>
<li>First-fit(首次适配)</li>
<li>Best-fit(最佳适配)</li>
<li>Worst-fit(最差适配)</li>
</ul>
<h4 id="Fragmentation-碎片"><a href="#Fragmentation-碎片" class="headerlink" title="Fragmentation(碎片)"></a>Fragmentation(碎片)</h4><p>Free memory holes between allocated ones are called <strong>external fragmentation</strong>外部碎片</p>
<p> memory that is allocated to a partition, but is not used, are called <strong>internal fragmentation</strong>内部碎片</p>
<p>外部碎片不可避免</p>
<h4 id="Compaction-for-External-Fragmentation"><a href="#Compaction-for-External-Fragmentation" class="headerlink" title="Compaction for External Fragmentation"></a>Compaction for External Fragmentation</h4><p>Compaction is possible <strong>only</strong> if relocation is dynamic, and is done at execution time</p>
<p>compaction scheme can be expensive</p>
<p><img src="/31/Chapter%208%20%20Memory%20Management/C:%5CUsers%5Ckali_chenye%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1589510716937.png" alt="1589510716937"></p>
<p>AC 连续分配容易通过base和limit寄存器实现内存保护</p>
<h2 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h2><p>不连续分配的一种方法</p>
<p> Divide physical memory into fixed-sized blocks called <strong>frames(帧)</strong></p>
<p> Divide logical memory into blocks of same size called <strong>pages(页)</strong></p>
<ul>
<li>Keep track of all free frames. </li>
<li>To run a program of size n pages, need to find n free frames and load program. </li>
<li>Set up a page table to translate logical to physical addresses. </li>
<li>Internal fragmentation.</li>
</ul>
<p>平均Internal fragmentation的大小是半个frame/page</p>
<h3 id="Address-Translation-Scheme"><a href="#Address-Translation-Scheme" class="headerlink" title="Address Translation Scheme"></a>Address Translation Scheme</h3><p>Address generated by CPU is divided into:</p>
<ul>
<li>Page number(p)</li>
<li>Page offset (d)</li>
</ul>
<p><img src="/31/Chapter%208%20%20Memory%20Management/C:%5CUsers%5Ckali_chenye%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1589510062828.png" alt="1589510062828"></p>
<p>logical–&gt; pages</p>
<p>physical–&gt;frames</p>
<h3 id="Implementation-of-Page-Table"><a href="#Implementation-of-Page-Table" class="headerlink" title="Implementation of Page Table"></a>Implementation of Page Table</h3><ul>
<li>Page table is kept in main memory.</li>
<li><strong>Page-table base register (PTBR)</strong>points to the page table</li>
</ul>
<p>TLB 快表: Hit ratio = α</p>
<p>Effective Access Time (EAT)</p>
<p>​     EAT = (1 + ε) α+ (2 + ε）(1 –α) = 2 + ε- α</p>
<h4 id="Memory-Protection"><a href="#Memory-Protection" class="headerlink" title="Memory Protection"></a>Memory Protection</h4><p>Memory protection implemented by associating protection bit with each frame</p>
<p><strong>Valid-invalid bit</strong>:</p>
<ul>
<li><p><strong>valid</strong></p>
</li>
<li><p><strong>invalid</strong>: the page is not in the process’ logical address space</p>
<p>we can use a <strong>page table length register (PTLR)</strong> that stores the length of a process’s page table.–&gt;a process cannot access the memory beyond its region</p>
</li>
</ul>
<h3 id="Page-Table-Structure"><a href="#Page-Table-Structure" class="headerlink" title="Page Table Structure"></a>Page Table Structure</h3><p>Hierarchical Page Tables 分级页表：</p>
<p>Break up the logical address space into multiple page tables</p>
<p><img src="/31/Chapter%208%20%20Memory%20Management/C:%5CUsers%5Ckali_chenye%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1589514600311.png" alt="1589514600311"></p>
<p><strong><em>Answer： 8 7 9</em></strong></p>
<p>Hashed Page Tables</p>
<p>Inverted Page Table</p>
]]></content>
  </entry>
  <entry>
    <title>Chapter 5 Thread</title>
    <url>/2020/04/09/Chapter%205%20Thread/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qq_43721475/article/details/104834649" target="_blank" rel="noopener">OS Review Chapter 1: Introduction</a><br><a href="https://blog.csdn.net/qq_43721475/article/details/104836492" target="_blank" rel="noopener">OS Review Chapter 2: Computer-System Structures</a><br><a href="https://blog.csdn.net/qq_43721475/article/details/104846186" target="_blank" rel="noopener">OS Review Chapter 3: Operating-System Structures</a><br><a href="https://blog.csdn.net/qq_43721475/article/details/105397752" target="_blank" rel="noopener">OS Review Chapter 4: Process</a><br><a href="https://blog.csdn.net/qq_43721475/article/details/105404697" target="_blank" rel="noopener">OS Review Chapter 5: Thread</a></p>
<h1 id="Chapter-5-Thread"><a href="#Chapter-5-Thread" class="headerlink" title="Chapter 5 Thread"></a>Chapter 5 Thread</h1><p>What is a thread?–A thread, also known as lightweight process (LWP),<strong>is a basic unit of CPU execution.</strong></p>
<p>A thread has a thread ID, a program counter, a register set, and a stack–similar to a process</p>
<p>*<em>However, a thread shares with other threads in the same process its code section, data section, and other OS resources (e.g., files and signals). *</em></p>
<p><img src="../images/c51.png" alt="1586356695921"></p>
<p>同一个进程的多个线程共享该进程的其他资源（不包括CPU、寄存器、栈）</p>
<p>Linux中不存在线程进程的概念，同一称作task</p>
<p><code>图片无法加载请跳转至csdn</code></p>
<a id="more"></a>

<h2 id="Thread-Usage"><a href="#Thread-Usage" class="headerlink" title="Thread Usage"></a>Thread Usage</h2><p><img src="../images//c52.png" alt="1586357091134"></p>
<h2 id="Benefits"><a href="#Benefits" class="headerlink" title="Benefits"></a>Benefits</h2><ul>
<li>Responsiveness</li>
<li>Resource Sharing (进程之间资源共享需要调用系统调用，需要频繁切换到kernel)</li>
<li>Economy (创建时的开销)</li>
<li>Utilization of MP(multi processors) Architectures</li>
</ul>
<h2 id="User-Threads"><a href="#User-Threads" class="headerlink" title="User Threads"></a>User Threads</h2><p>Thread management done by user-level threads library  –POSIX Pthreads </p>
<p>用户线程阻塞会导致该进程的其他线程阻塞，kernel不知道process中的其他thread，认为这个process是阻塞的。 if one thread is blocked, every other threads of the same process are also blocked because the containing process is blocked.</p>
<p>User threads are supported at the user level. The kernel is not aware of user threads. </p>
<p>A library provides all support for thread creation, termination, joining, and scheduling. There is no kernel intervention, and, hence, user threads are usually more efficient. </p>
<p><img src="../images//c53.png" alt="1586358017933"></p>
<h2 id="Kernel-Threads"><a href="#Kernel-Threads" class="headerlink" title="Kernel Threads"></a>Kernel Threads</h2><p>Kernel threads are directly supported by the kernel. The kernel does thread creation,termination, joining, and scheduling in kernel space. </p>
<p>Kernel threads are usually slower than the user threads.</p>
<p>通常是用户创建一个kernel thread，导致kernel需要进行系统调用陷入内核，创建完成后返回用户态</p>
<p>However, blocking one thread will not cause other threads of the same process to block. The kernel simply runs other threads. </p>
<p><strong>In a multiprocessor environment, the kernel can schedule threads on different processors</strong></p>
<h2 id="Multithreading-Models"><a href="#Multithreading-Models" class="headerlink" title="Multithreading Models"></a>Multithreading Models</h2><h3 id="Many-to-One"><a href="#Many-to-One" class="headerlink" title="Many-to-One"></a>Many-to-One</h3><p> 多对一模型：多个用户级线程线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。<br>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。<br>缺点：当一个用户线程阻塞后，整个进程就会都阻塞，并发度不高。多个线程不可在多处理机上并行运行。 </p>
<h3 id="One-to-One"><a href="#One-to-One" class="headerlink" title="One-to-One"></a>One-to-One</h3><p> 一个用户进程对应一个内核进程。每个用户有与内核进程相同数量的用户进程。<br>优点：当一个线程被阻塞后，另外的线程还可以继续执行，并发性强。多线程可在多核处理机上并发执行<br>缺点：一个用户线程会占用多个内核级线程，线程切换是需要将用户态转换为核心态，因此线程管理的成本高，开销大。 </p>
<h3 id="Many-to-Many"><a href="#Many-to-Many" class="headerlink" title="Many-to-Many"></a>Many-to-Many</h3><p>Allows many user level threads to be mapped to many kernel threads. Allows the  operating system to create a sufficient number of kernel threads. </p>
<p> 多对多模型：n个用户级线程映射到m个内核级线程（n&gt;=m）。每个用户进程对应m个内核级线程。<br>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。 </p>
<h2 id="Threading-Issues"><a href="#Threading-Issues" class="headerlink" title="Threading Issues"></a>Threading Issues</h2><p>Semantics of fork() and exec() system calls. ？？？</p>
<h3 id="Thread-cancellation"><a href="#Thread-cancellation" class="headerlink" title="Thread cancellation."></a>Thread cancellation.</h3><ul>
<li><strong>Asynchronous cancellation</strong> terminates the target thread  immediately （实现过程简单）</li>
<li><strong>Deferred cancellation *<em>allows the target thread to periodically check if it should be cancelled ：The point a thread can terminate itself is a *</em>cancellation point</strong>（延迟，安全撤销）</li>
</ul>
<p>Pthread supports deferred cancellation.</p>
<p>With asynchronous cancellation, if the target thread owns some system-wide resources, the system may not be able to reclaim all recourses. </p>
<p>But for deferred cancellation,Reclaiming resources is not a problem.</p>
<h2 id="Signal-Handling"><a href="#Signal-Handling" class="headerlink" title="Signal Handling"></a>Signal Handling</h2><h2 id="Thread-Pools"><a href="#Thread-Pools" class="headerlink" title="Thread Pools"></a>Thread Pools</h2><p>Create a number of threads in a pool where they await work .</p>
<p>通常线程池中的线程数目是adaptive（自适应的）</p>
<p>Advantages: </p>
<p>◆Usually slightly faster to service a request with an existing thread than create a new thread </p>
<p>◆Allows the number of threads in the application(s) to be bound to the size of the pool</p>
<h3 id="Solaris-2-Threads"><a href="#Solaris-2-Threads" class="headerlink" title="Solaris 2 Threads"></a>Solaris 2 Threads</h3><p>M:M</p>
<p><img src="../images//c54.png" alt="1586396393345"></p>
<h2 id="Windows-XP-Threads"><a href="#Windows-XP-Threads" class="headerlink" title="Windows XP Threads"></a>Windows XP Threads</h2><p>Implements the one-to-one mapping. </p>
<p>Each thread contains</p>
<ul>
<li>a thread id -</li>
<li>register set </li>
<li>separate user and kernel stacks </li>
<li>private data storage area</li>
</ul>
<p><img src="../images//c55.png" alt="1586397994132"></p>
<p>TEB: Thread Enviroment Block</p>
<h2 id="Linux-Threads"><a href="#Linux-Threads" class="headerlink" title="Linux Threads"></a>Linux Threads</h2><p>linux中的进程已经十分高效，引入线程作为资源共享的一个手段</p>
<p>Linux refers to them as tasks rather than threads.</p>
<p>Thread creation is done through clone() system call. Clone() allows a child task to share the address space of the parent task (process)</p>
<h2 id="Windows-Thread-APIs"><a href="#Windows-Thread-APIs" class="headerlink" title="Windows Thread APIs"></a>Windows Thread APIs</h2><ul>
<li>CreateThread </li>
<li>GetCurrentThreadId - returns global ID </li>
<li>GetCurrentThread - returns handle </li>
<li>SuspendThread/ResumeThread </li>
<li>ExitThread </li>
<li>TerminateThread </li>
<li>GetExitCodeThread </li>
<li>GetThreadTimes</li>
</ul>
<p>Example：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;synchapi.h&gt;</span></span></span><br><span class="line">BOOL thrdDone = FALSE;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">Fibonacci</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = a+b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i+<span class="number">1</span>&lt;&lt;<span class="string">" : "</span>&lt;&lt;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = n;</span><br><span class="line">        n = a + n;</span><br><span class="line">    &#125;</span><br><span class="line">    thrdDone = TRUE;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"enter the number of the Fibonacci:  "</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    HANDLE hThread;</span><br><span class="line">    hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)Fibonacci, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line">    <span class="keyword">while</span> (!thrdDone);</span><br><span class="line">    DWORD dw=WaitForSingleObject( hThread, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; dw;</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; "Hello World!\n";</span></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Example Explained: Main thread is process When process goes, all threads go Need some methods of waiting for a thread to finish</p>
<h3 id="Threads-states"><a href="#Threads-states" class="headerlink" title="Threads states"></a>Threads states</h3><p>pthread threads have two states</p>
<p> ◆joinable and detached </p>
<p>threads are joinable by default </p>
<p>◆Resources are kept until pthread_join </p>
<p>◆can be reset with attribute or API call </p>
<p>detached thread can not be joined </p>
<p>◆resources can be reclaimed at termination </p>
<p>◆cannot reset to be joinable</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SEQUENCE 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一组数据，用于创建线程时作为参数传入</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">     <span class="keyword">int</span> num; <span class="comment">//斐波那契数列的项数</span></span><br><span class="line">     <span class="keyword">int</span> Fibo[MAX_SEQUENCE];<span class="comment">//最大容量，斐波那契数列</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Fibonacci</span><span class="params">(<span class="keyword">void</span> *data)</span></span>&#123;<span class="comment">//获得斐波那契数列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> *<span class="title">tmp</span> = (<span class="title">struct</span> <span class="title">Data</span>*)<span class="title">data</span>;</span><span class="comment">//转化为实际类型</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(  tmp-&gt;num == <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error!enter a number larger than 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( tmp-&gt;num == <span class="number">1</span> )&#123;</span><br><span class="line">        tmp-&gt;Fibo[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp-&gt;Fibo[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    tmp-&gt;Fibo[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">2</span>; i &lt; tmp-&gt;num; i++ )&#123;</span><br><span class="line">        tmp-&gt;Fibo[i] = tmp-&gt;Fibo[i<span class="number">-1</span>] + tmp-&gt;Fibo[i<span class="number">-2</span>]; </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> th;<span class="comment">//线程标识符</span></span><br><span class="line">    <span class="keyword">int</span> ret; <span class="comment">//pthread的返回值 ret = 0,创建线程成功</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The fibonacci produce programe!\nPlease input an number within 1~200: "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span> || n &gt; <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Your input is error."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    data.num = n;<span class="comment">//赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//create a thread</span></span><br><span class="line">    ret = pthread_create(&amp;th, <span class="literal">NULL</span>, Fibonacci, (<span class="keyword">void</span> *)&amp;data);</span><br><span class="line">    <span class="keyword">if</span>( ret != <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Create thread error!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞调用线程</span></span><br><span class="line">    pthread_join( th, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出斐波那契数列</span></span><br><span class="line">    <span class="keyword">if</span>( data.num == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Nothing output."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The Fibonacci items are:  "</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,data.Fibo[i]);</span><br><span class="line">	    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/qq_43721475/article/details/104834649" target="_blank" rel="noopener">OS Review Chapter 1: Introduction</a><br><a href="https://blog.csdn.net/qq_43721475/article/details/104836492" target="_blank" rel="noopener">OS Review Chapter 2: Computer-System Structures</a><br><a href="https://blog.csdn.net/qq_43721475/article/details/104846186" target="_blank" rel="noopener">OS Review Chapter 3: Operating-System Structures</a><br><a href="https://blog.csdn.net/qq_43721475/article/details/105397752" target="_blank" rel="noopener">OS Review Chapter 4: Process</a><br><a href="https://blog.csdn.net/qq_43721475/article/details/105404697" target="_blank" rel="noopener">OS Review Chapter 5: Thread</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java多线程</title>
    <url>/2020/03/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>方法间的调用：普通方法的调用，从哪来到哪里去，闭合的一条路径</li>
<li>多线程的使用：开辟了多条路径</li>
</ul>
<h3 id="程序、进程与线程"><a href="#程序、进程与线程" class="headerlink" title="程序、进程与线程"></a>程序、进程与线程</h3><p>在操作系统中运行的程序就是进程，如看视频，一个进程（Process）可以有多个线程（Thread），如视频中同时听声音，看图像，显示字幕等等</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NzA1MTcyMA==&mid=403498894&idx=2&sn=219c1a6001b5bb7e6bdc7963b1af8450&scene=2&srcid=0330UDNmQ" target="_blank" rel="noopener">很有意思的关于线程的理解</a></p>
<ol>
<li><p>进程是资源管理的最小单位，线程是程序执行的最小单位。</p>
</li>
<li><p>每个进程都有自己的数据段、代码段和堆栈段。线程是轻量级的进程，它包含独立的栈和CPU寄存器状态，线程是进程的一条执行路径，每个线程共享其所附属进程的所有资源，包括打开的文件、内存页面、信号标识以及动态分配的内存等。</p>
</li>
<li><p>因为线程和进程比起来很小，所以相对来说，线程花费更少的CPU资源。</p>
</li>
<li><p>在操作系统设计上，从进程演化出线程，最主要的目的就是更好的支持多处理器，并且减少进程上下文切换的开销。</p>
</li>
<li><p>线程和进程的关系：线程是属于进程的，线程运行在进程空间内，同一进程所产生的的线程共享同一用户内存空间，当进程退出时该进程所产生的线程都会被强制退出并清除。所以，线程不能独立地执行，它必须依附在一个运行的应用程序上（即进程上），而一个进程至少需要一个线程作为它的指令执行，进程管理着资源（比如CPU、内存、文件等等）。而将线程分配到某个CPU上执行。</p>
</li>
</ol>
<p>线程和进程的区别：</p>
<p><img src="../images/5.jpg" alt></p>
<a id="more"></a>

<p>当操作系统分配给进程资源后，同属一个进程的多个线程之间可以相互共享进程中的内存资源，原因是线程没有自己独立的内存资源，它只有自己执行的堆栈和局部变量。而多个进程之间每个进程都拥有自己的一整套变量，即每个进程都有自己独立的内存单元。这就使得多线程之间的通信比多进程之间的通信更加的容易和高效。</p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
<li>实现Callable接口</li>
</ul>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程方式一</span></span><br><span class="line"><span class="comment"> * 继承Thread，重写run方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 线程入口点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"listening to music "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//super.run();</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;StartThread&gt; <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//启动线程 调用子类对象</span></span><br><span class="line">		<span class="comment">//创建子类对象</span></span><br><span class="line">		TestThread st=<span class="keyword">new</span> TestThread();</span><br><span class="line">		<span class="comment">//启动多线程</span></span><br><span class="line">		st.start();<span class="comment">//不保证立即调用，由CPU决定调用,等待调度</span></span><br><span class="line">		<span class="comment">//st.run();//普通方法的调用，没有开启多线程</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"while coding "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程方式二</span></span><br><span class="line"><span class="comment"> * 创建：实现runnable+重写run</span></span><br><span class="line"><span class="comment"> * 启动：创建实现类对象+thread对象+start</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 线程入口点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"listening to music "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//super.run();</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;StartThread&gt; <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//启动线程  创建实现类对象</span></span><br><span class="line">		StartRun st=<span class="keyword">new</span> StartRun();</span><br><span class="line">		<span class="comment">//创建代理类对象</span></span><br><span class="line">		Thread t=<span class="keyword">new</span> Thread(st);</span><br><span class="line">		<span class="comment">//启动多线程</span></span><br><span class="line">		t.start();</span><br><span class="line">		<span class="comment">//st.run();//普通方法的调用，没有开启多线程</span></span><br><span class="line">		<span class="comment">/**代码匿名，如果一个对象只使用一次</span></span><br><span class="line"><span class="comment">		new Thread(new StartRun()).start();</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"while coding "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>推荐使用这种方法，避免了单继承的局限性，OOP多实现，灵活方便，方便统一份对象的代理</em></strong></p>
<p>模拟12306抢票的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 共享资源,并发</span></span><br><span class="line"><span class="comment"> * 需要保证线程安全</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Web12306</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticketNums=<span class="number">99</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(ticketNums&lt;<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;"</span>+ticketNums--);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对同一个资源进行多个代理</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//一份资源</span></span><br><span class="line">		Web12306 web=<span class="keyword">new</span> Web12306();</span><br><span class="line">		<span class="comment">//多个代理</span></span><br><span class="line">		<span class="keyword">new</span> Thread(web,<span class="string">"1"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(web,<span class="string">"2"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(web,<span class="string">"3"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟龟兔赛跑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟龟兔赛跑</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Racer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String winner;<span class="comment">//胜利者</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">1</span>;step&lt;=<span class="number">100</span>;step++) &#123;</span><br><span class="line">			<span class="comment">//模拟休息,设置延时</span></span><br><span class="line">			<span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">"兔子"</span>)&amp;&amp;step%<span class="number">10</span>==<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">100</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;"</span>+step);</span><br><span class="line">			<span class="comment">//判断比赛是否结束</span></span><br><span class="line">	</span><br><span class="line">			<span class="keyword">boolean</span> flag=gameOver(step);</span><br><span class="line">			<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">gameOver</span><span class="params">(<span class="keyword">int</span> steps)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(winner!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(steps==<span class="number">100</span>) &#123;</span><br><span class="line">				winner=Thread.currentThread().getName();</span><br><span class="line">				System.out.println(<span class="string">"winner==&gt;"</span>+winner);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Racer racer=<span class="keyword">new</span> Racer();</span><br><span class="line">		<span class="keyword">new</span> Thread(racer,<span class="string">"乌龟"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(racer,<span class="string">"兔子"</span>).start();</span><br><span class="line">		<span class="comment">//racer.gameOver(100);</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><p>了解，并发变成JUC  重写call方法</p>
<h2 id="静态代理设计模式"><a href="#静态代理设计模式" class="headerlink" title="静态代理设计模式"></a>静态代理设计模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态代理</span></span><br><span class="line"><span class="comment"> * 公共接口：</span></span><br><span class="line"><span class="comment"> * 1.真实角色</span></span><br><span class="line"><span class="comment"> * 2.代理角色</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> WeddingCompany(<span class="keyword">new</span> You()).happyMarry();</span><br><span class="line">		<span class="comment">//new Thread(线程对象).start();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">happyMarry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"you get in love with her!!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeddingCompany</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Marry targe;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WeddingCompany</span><span class="params">(Marry target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.targe=target;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		ready();</span><br><span class="line">		<span class="keyword">this</span>.targe.happyMarry();</span><br><span class="line">		after();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"准备"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"清理"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="lambda推导-简化线程"><a href="#lambda推导-简化线程" class="headerlink" title="lambda推导 简化线程"></a>lambda推导 简化线程</h2><ul>
<li>避免匿名内部类定义过多</li>
<li>实质属于函数式编程的概念</li>
</ul>
<p>lambda表达式即将正式取代Java代码中的匿名内部类。匿名类的 this 关键字指向匿名类，而lambda表达式的 this 关键字指向包围lambda表达式的类。</p>
<p>java8中Lambda表达式的书写方式：<br>(参数) -&gt; 表达式<br>(参数) -&gt; 语句<br>(参数) -&gt; { 语句 }<br>例如，如果你的方法只是在控制台打印信息，则可以这么写：<br>() -&gt; System.out.println(“Hello Lambda Expressions”);</p>
<p>如果你的方法接收两个参数，那么：<br>(int even, int odd) -&gt; even + odd<br>原文链接：<a href="https://blog.csdn.net/iteye_3843/article/details/82570449" target="_blank" rel="noopener">https://blog.csdn.net/iteye_3843/article/details/82570449</a></p>
<p>*<em>以下是lambda的推导过程 *</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * lambda推导的过程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 陈烨</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">	<span class="comment">//静态内部类</span></span><br><span class="line">	 <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Like2</span> <span class="keyword">implements</span> <span class="title">ILike</span></span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			System.out.println(<span class="string">"i like lambda2"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ILike like = <span class="keyword">new</span> Like();</span><br><span class="line">		like.lambda();</span><br><span class="line">		like = <span class="keyword">new</span> Like2(); </span><br><span class="line">		like.lambda();</span><br><span class="line">		<span class="comment">//方法内部类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">Like3</span> <span class="keyword">implements</span> <span class="title">ILike</span></span>&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				System.out.println(<span class="string">"i like lambda3"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		like = <span class="keyword">new</span> Like3(); </span><br><span class="line">		like.lambda();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//匿名内部类</span></span><br><span class="line">		like = <span class="keyword">new</span> ILike() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"i like lambda4"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		like.lambda();</span><br><span class="line">		<span class="comment">//lambda实现</span></span><br><span class="line">		like=()-&gt;&#123;</span><br><span class="line">			System.out.println(<span class="string">"i like lambda5"</span>);</span><br><span class="line">		&#125;;</span><br><span class="line">		like.lambda();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ILike</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//void lambda2();//lambda实现中只能有一个接口</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Like</span> <span class="keyword">implements</span> <span class="title">ILike</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"i like lambda1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lambda参数的简单使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * lambda的使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">				System.out.println(<span class="string">"studying ..."</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread(()-&gt;System.out.println(<span class="string">"Coding..."</span>)).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/C:%5CUsers%5CASUS%5CDesktop%5Cimg_0153.png" alt="img_0153"></p>
<p>在Java当中，线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。<br>　　第一是创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。<br>　　第二是就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。<br>　　第三是运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。<br>　　第四是阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。<br>　　第五是死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪。</p>
<p><img src="/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/C:%5CUsers%5CASUS%5CDesktop%5Cimg_0154.png" alt="img_0154"></p>
<h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><p> 线程终止</p>
<ul>
<li>1 线程正常执行完毕 –次数</li>
<li>2 外部干涉– 使用标志位</li>
<li>不要使用 stop destroy 线程不安全</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程终止</span></span><br><span class="line"><span class="comment"> * 1 线程正常执行完毕 --次数</span></span><br><span class="line"><span class="comment"> * 2 外部干涉-- 使用标志位</span></span><br><span class="line"><span class="comment"> * 不要使用 stop destroy 线程不安全</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminateThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="comment">//1 加入标识  标记线程具体是否可以运行</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> flag =<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">	String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TerminateThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">//2 关联标识  true--&gt;运行false--》停止</span></span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(flag) &#123;</span><br><span class="line">			System.out.println(name+<span class="string">"--&gt;"</span>+i++);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//3 对外提供方法 改变标识</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">terminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.flag=<span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TerminateThread tt=<span class="keyword">new</span> TerminateThread(<span class="string">"chenye"</span>);</span><br><span class="line">		<span class="keyword">new</span> Thread(tt).start();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">99</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">88</span>) &#123;</span><br><span class="line">				tt.terminate();<span class="comment">//外部控制线程的终止</span></span><br><span class="line">				System.out.println(<span class="string">"Game Over"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"main--&gt;"</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="暂停-sleep"><a href="#暂停-sleep" class="headerlink" title="暂停 sleep"></a>暂停 sleep</h3><ul>
<li>指定当前线程阻塞的毫秒数</li>
<li>sleep存在异常InterruptedException</li>
<li>sleep时间达到后线程进入就绪状态</li>
<li>可以用来模拟网络延时、倒计时等</li>
<li>每一个对象都有一把锁，sleep不会释放锁</li>
</ul>
<h3 id="礼让-yield"><a href="#礼让-yield" class="headerlink" title="礼让 yield"></a>礼让 yield</h3><ul>
<li>礼让线程，让当前正在执行线程暂停</li>
<li>不是进入阻塞线程，而是将线程从运行状态转入就绪状态</li>
<li>让CPU调度器重新调度</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 礼让线程,暂停线程 进入就绪状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		  MyYield my=<span class="keyword">new</span>  MyYield();</span><br><span class="line">		<span class="keyword">new</span> Thread(my,<span class="string">"a"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(my,<span class="string">"b"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyYield</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;start"</span>);</span><br><span class="line">		Thread.yield();<span class="comment">//礼让  重回调度器</span></span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;start"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插队-join"><a href="#插队-join" class="headerlink" title="插队 join"></a>插队 join</h3><ul>
<li>合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞</li>
</ul>
<p>通过getState监视线程的状态</p>
<h2 id="优先级-Priority"><a href="#优先级-Priority" class="headerlink" title="优先级 Priority"></a>优先级 Priority</h2><p>java的线程优先级总共有10个级别,从1到10,1为优先级最小,10为最大。通过线程的setPriority（int）方法来设置优先级。<br>优先级也并非绝对的优先级，低优先级的线程有时候还是会先于高优先级的线程运行</p>
<p>默认的优先级是5，设置优先级要在启动之前</p>
<p><a href="https://blog.csdn.net/qq_43721475/article/details/104266214" target="_blank" rel="noopener">https://blog.csdn.net/qq_43721475/article/details/104266214</a></p>
<h2 id="守护线程-daemon"><a href="#守护线程-daemon" class="headerlink" title="守护线程 daemon"></a>守护线程 daemon</h2><p>java线程分为两种，用户线程即普通的线程包括主线程、以及守护线程。<br>守护线程主要用于后台提供服务，比如垃圾回收线程，后台记录操作日志，监控内存使用等</p>
<p>虚拟机必须确保用户线程执行完毕，不用等待守护线程执行完毕</p>
<p>守护线程与用户线程区别<br>用户线程，也叫做非守护线程。<br>1.当所有的用户线程被杀死时，jvm会退出。<br>2.用户线程可以在线程启动前手动调用setDaemon（true）的方法来把线程转化为守护线程。反之设置为false则为用户线程。<br>3.用户线程产生的线程默认为用户线程，而守护线程产生的线程默认为守护线程<br>4.守护线程可能会随时发生中断，所以不适合去访问如文件，数据库等资源，防止内存泄漏</p>
<p><a href="https://www.cnblogs.com/lixuan1998/p/6937986.html" target="_blank" rel="noopener">关于守护线程</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认用户线程 jvm等待用户线程执行完毕才会停止</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		God g=<span class="keyword">new</span> God();</span><br><span class="line">		Yourself y=<span class="keyword">new</span> Yourself();</span><br><span class="line">		Thread t=<span class="keyword">new</span> Thread(g);</span><br><span class="line">		t.setDaemon(<span class="keyword">true</span>);<span class="comment">//将用户线程设置为守护</span></span><br><span class="line">		t.start();</span><br><span class="line">		<span class="keyword">new</span> Thread(y).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Yourself</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"be happy"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"over"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">God</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;<span class="keyword">true</span>;) &#123;</span><br><span class="line">			System.out.println(<span class="string">"bless you ......"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">//	System.out.println("over");</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>所谓并发执行,是为了增强计算机系统的处理能力和提高资源利用率锁采取的一种同时操作技术.</p>
<p>异步：程序中的两部分在执行上没有顺序规定</p>
<p>同步：把异步环境下的一组并发进程,因直接制约而互相发送消息而进行互相合作,互相等待,使得各进程按一定的速度执行的过程称之为进程间的同步</p>
<p>非同步将会导致线程的不安全</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>处理多线程问题时，多个线程访问同一个对象，某些线程需要修改这个对象，这个时候需要引入线程同步。线程同步就是一种等待机制，多个需要同时访问这个对象的线程进入这个对象的<strong>等待池</strong>形成对列，等待前一个线程使用完毕后，下一个线程再使用。</p>
<h3 id="队列与锁"><a href="#队列与锁" class="headerlink" title="队列与锁"></a>队列与锁</h3><p>同一个进程的多个线程共享同一块存储空间，带来了访问冲突问题。为了保证数据在方法中被访问的正确性，在访问中加入锁机制（synchronized），当一个线程获得对象时加上锁，独占资源，其他线程必须等待。在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题。</p>
<p><strong>如果将一个大的方法声明为synchronized将会大大影响效率</strong></p>
<p><a href="https://blog.csdn.net/zhouyong723/article/details/80330383" target="_blank" rel="noopener">简单有趣的例子</a></p>
<ol>
<li><p>同步锁：Java里面的同步锁机制：当一个线程执行synchronized修饰的代码段时，会给监视器上一把锁，当另一个线程执行同样的被synchronized修饰的任务时，该线程就需要关注该监视器有没有上锁，没有才能执行，否则就阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Task task = <span class="keyword">new</span> Task();</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"顾客正在挑选衣服..."</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"顾客正在试衣服..."</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"顾客正在结账..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Task task = <span class="keyword">new</span> Task();</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		......................................</span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">"顾客正在试衣服..."</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		............................</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>互斥锁：当两个synchronized锁的对象（监视器）是同一个，修饰的代码片段不同时，那么这些代码片段所代表的任务是互斥的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Task task = <span class="keyword">new</span> Task();</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">"吃饭..."</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">"看电视..."</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>死锁现象：这里是因为滥用锁对象造成的，大家可以将两个锁对象（监视器）换成同一个对象，程序就会向下继续运行，但是该程序继续向下运行并没有什么意义</p>
</li>
</ol>
<p>简单的死锁的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Task task = <span class="keyword">new</span> Task();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">				task.methodA();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">				task.methodB();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object a = <span class="keyword">new</span> Object();</span><br><span class="line">	<span class="keyword">private</span> Object b = <span class="keyword">new</span> Object();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"开始执行A方法"</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">synchronized</span>(a)&#123;</span><br><span class="line">			System.out.println(<span class="string">"对A方法上锁"</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"开始调用B方法"</span>);</span><br><span class="line">			methodB();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"A方法执行完毕"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"开始执行B方法"</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">synchronized</span>(b)&#123;</span><br><span class="line">			System.out.println(<span class="string">"对B方法上锁"</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"开始调用A方法"</span>);</span><br><span class="line">			methodA();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"B方法执行完毕"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="synchronized块"><a href="#synchronized块" class="headerlink" title="synchronized块"></a>synchronized块</h3><p>同步块 synchronized(obj){} obj 称之为同步监视器</p>
<p>同步监视器的执行过程：</p>
<ol>
<li>第一个线程访问，锁定同步监视器，执行其中的代码</li>
<li>第二个线程访问，发现同步监视器被锁定，无法访问</li>
<li>第一个线程访问完毕，解锁同步监视器</li>
<li>第二个我线程访问，发现同步监视器未锁，锁定并访问</li>
</ol>
<p>普通块、局部块、静态块</p>
<h3 id="电影院订票系统1-0"><a href="#电影院订票系统1-0" class="headerlink" title="电影院订票系统1.0"></a>电影院订票系统1.0</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟电影院购票系统</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HappyCinema</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Cinema c1=<span class="keyword">new</span> Cinema(<span class="string">"星河国际"</span>,<span class="number">20</span>);</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Customer(c1,<span class="number">2</span>),<span class="string">"chenye"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Customer(c1,<span class="number">3</span>),<span class="string">"zmj"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顾客</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	Cinema ci;</span><br><span class="line">	<span class="keyword">int</span> seats;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Cinema ci, <span class="keyword">int</span> seats)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.ci = ci;</span><br><span class="line">		<span class="keyword">this</span>.seats = seats;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(ci) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">boolean</span> flag=ci.bookTickets(seats);</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"订购成功"</span>+Thread.currentThread().getName()+<span class="string">"--位置为："</span>+seats);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"订购成功"</span>+Thread.currentThread().getName()+<span class="string">"-出票失败，位置不够"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//影院</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cinema</span></span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> avilable;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cinema</span><span class="params">(String name, <span class="keyword">int</span> avilable)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.avilable = avilable;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bookTickets</span><span class="params">(<span class="keyword">int</span> seats)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"可用的位置"</span>+avilable);</span><br><span class="line">		<span class="keyword">if</span>(seats&gt;avilable) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		avilable=avilable-seats;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="电影院订票系统2-0"><a href="#电影院订票系统2-0" class="headerlink" title="电影院订票系统2.0"></a>电影院订票系统2.0</h3><p>使用List容器，要保证每一个位子只能由一个顾客选中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟电影院购票系统</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HappyCinema2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//可用的位置</span></span><br><span class="line">		List&lt;Integer&gt; available=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">		available.add(<span class="number">1</span>);</span><br><span class="line">		available.add(<span class="number">2</span>);</span><br><span class="line">		available.add(<span class="number">3</span>);</span><br><span class="line">		available.add(<span class="number">4</span>);</span><br><span class="line">		available.add(<span class="number">5</span>);</span><br><span class="line">		available.add(<span class="number">6</span>);</span><br><span class="line">		available.add(<span class="number">7</span>);</span><br><span class="line">		<span class="comment">//顾客需要的位置</span></span><br><span class="line">		List&lt;Integer&gt; seat3=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">		seat3.add(<span class="number">1</span>);</span><br><span class="line">		seat3.add(<span class="number">2</span>);</span><br><span class="line">		List&lt;Integer&gt; seat4= <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">		seat4.add(<span class="number">4</span>);</span><br><span class="line">		seat4.add(<span class="number">5</span>);</span><br><span class="line">		Cinema2 c=<span class="keyword">new</span> Cinema2(<span class="string">"星河国际"</span>,available);</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Customer2(c,seat3),<span class="string">"chenye"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Customer2(c,seat4),<span class="string">"zmj"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顾客</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	Cinema2 ci;</span><br><span class="line">	List&lt;Integer&gt; seats;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Customer2</span><span class="params">(Cinema2 ci, List&lt;Integer&gt; seats)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.ci = ci;</span><br><span class="line">		<span class="keyword">this</span>.seats = seats;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(ci) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">boolean</span> flag=ci.bookTickets(seats);</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"订购成功"</span>+Thread.currentThread().getName()+<span class="string">"--位置为："</span>+seats);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"订购成功"</span>+Thread.currentThread().getName()+<span class="string">"-出票失败，位置不够"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//影院</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cinema2</span></span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	List&lt;Integer&gt; available;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cinema2</span><span class="params">(String name,List&lt;Integer&gt; available)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//super();</span></span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.available = available;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bookTickets</span><span class="params">(List&lt;Integer&gt;seats)</span> </span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">"欢迎您选购，可用的位置"</span>+available);</span><br><span class="line">		List&lt;Integer&gt;copy=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">		copy.addAll(available);</span><br><span class="line">		<span class="comment">//相减</span></span><br><span class="line">		copy.removeAll(seats);</span><br><span class="line">		<span class="comment">//判断大小</span></span><br><span class="line">		<span class="keyword">if</span>(available.size()-copy.size()!=seats.size()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//成功</span></span><br><span class="line">		available=copy;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><p><a href="https://blog.csdn.net/qq_39158142/article/details/95049855" target="_blank" rel="noopener">这是一个可爱的链接–&gt;java并发容器</a></p>
<h2 id="并发协作"><a href="#并发协作" class="headerlink" title="并发协作"></a>并发协作</h2><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><ul>
<li>synchronized可阻止并发更新同一个共享资源，实现了同步</li>
<li>synchronized不能用来发现不同线程之间的信息传递（通信）</li>
</ul>
<p>Java提供了3个方法解决线程之间的通信问题，都只能在同步方法或者同步代码块中使用，否则会抛出异常</p>
<ul>
<li>final void wait(long timeout)</li>
<li>final void notify()</li>
<li>final void notifyAll()</li>
</ul>
<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p><img src="/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/C:%5CUsers%5CASUS%5CDesktop%5Cimg_0156.png" alt="img_0156"></p>
<h3 id="管程法解决生产者消费者模型"><a href="#管程法解决生产者消费者模型" class="headerlink" title="管程法解决生产者消费者模型"></a>管程法解决生产者消费者模型</h3><p>伪代码思路：借助缓冲区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;思路</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1.思考需要哪些对象?</span><br><span class="line">&#x2F;&#x2F; 生产 , 消费 , 产品 , 容器</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.分工</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">    生产者只管生产</span><br><span class="line">    消费者只管消费</span><br><span class="line">    鸡: 实体类</span><br><span class="line"></span><br><span class="line">    容器 :</span><br><span class="line"></span><br><span class="line">    容器添加数据.</span><br><span class="line">    要判断容器是否满 , 满了等待消费者消费</span><br><span class="line">    没有满,通知生产者生产</span><br><span class="line"></span><br><span class="line">    容器减少数据</span><br><span class="line">    判断还有没有数据, 没有数据的话 . 等待生产者生产</span><br><span class="line">    消费完毕 , 通知生产者生产</span><br><span class="line"> *&#x2F;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「dream_Felix」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;yalu_123456&#x2F;article&#x2F;details&#x2F;91050054</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chenye.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 协作模型：生产者消费者实现方式一：管程法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chenye</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cooparation</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	SynContainer container=<span class="keyword">new</span> SynContainer();</span><br><span class="line">	<span class="keyword">new</span> Productor(container).start();</span><br><span class="line">	<span class="keyword">new</span> Consumer(container).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Productor</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	SynContainer container;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Productor</span><span class="params">(SynContainer container)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.container = container;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//生产</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"生产--》"</span>+i+<span class="string">"个馒头"</span>);</span><br><span class="line">			container.push(<span class="keyword">new</span> Steamedbun(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	SynContainer container;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(SynContainer container)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.container = container;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//消费</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"消费--》"</span>+container.pop().id+<span class="string">"个馒头"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynContainer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	Steamedbun[] buns=<span class="keyword">new</span> Steamedbun[<span class="number">10</span>];<span class="comment">//存储容器</span></span><br><span class="line">	<span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//计数器</span></span><br><span class="line">	<span class="comment">//存储 生产</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Steamedbun bun)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//何时能生产 容器存在空间</span></span><br><span class="line">		<span class="comment">//不能生产 只有等待</span></span><br><span class="line">		<span class="keyword">if</span>(count==buns.length) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.wait();<span class="comment">//线程阻塞  消费者通知生产者解除</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//存在空间 可以生产</span></span><br><span class="line">		buns[count]=bun;</span><br><span class="line">		count++;</span><br><span class="line">		<span class="comment">//存在数据 可以通知消费了</span></span><br><span class="line">		<span class="keyword">this</span>.notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取 消费</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Steamedbun <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//何时能消费  容器中是否存在数据</span></span><br><span class="line">		<span class="comment">//没有数据 只有等待</span></span><br><span class="line">		<span class="keyword">if</span>(count==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.wait();<span class="comment">//线程阻塞  有生产者通知消费时解除阻塞</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//存在数据可以消费</span></span><br><span class="line">		count--;</span><br><span class="line">		Steamedbun bun=buns[count];</span><br><span class="line">		<span class="keyword">this</span>.notifyAll();<span class="comment">//存在空间，可以唤醒对方生产</span></span><br><span class="line">		<span class="keyword">return</span> bun;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Steamedbun</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> id;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Steamedbun</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.id = id;</span><br><span class="line">		&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号灯法"><a href="#信号灯法" class="headerlink" title="信号灯法"></a>信号灯法</h3><p>思路：借助标志位</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;生产者消费2</span><br><span class="line">&#x2F;&#x2F;生产者---&gt;演员</span><br><span class="line">&#x2F;&#x2F;消费者---&gt;观众</span><br><span class="line">&#x2F;&#x2F;产品:信号灯---&gt;电视-----&gt;声音</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TV tv = <span class="keyword">new</span> TV();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Player(tv).start();</span><br><span class="line">        <span class="keyword">new</span> Watcher(tv).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    TV tv;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(TV tv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.tv.play(<span class="string">"节目:快乐大本营播放中"</span>);</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.tv.play(<span class="string">"广告:抖音,记录美好生活"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    TV tv;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Watcher</span><span class="params">(TV tv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            tv.watch();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电视</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TV</span></span>&#123;</span><br><span class="line">    <span class="comment">//演员说话 , 观众等待</span></span><br><span class="line">    <span class="comment">//观众观看 , 演员等待</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说话</span></span><br><span class="line">    String voice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表演</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String voice)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//演员等待</span></span><br><span class="line">        <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"表演了"</span>+voice);</span><br><span class="line">        <span class="keyword">this</span>.voice = voice;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让观众观看</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//观看</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//观众等待</span></span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"观众听到了: "</span>+voice);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通知演员说话</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/yalu_123456/article/details/91050054" target="_blank" rel="noopener">Java多线程：线程通信：管程法和信号灯法，线程池的使用</a></p>
<h2 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h2><h3 id="任务定时调度"><a href="#任务定时调度" class="headerlink" title="任务定时调度"></a>任务定时调度</h3><p>通过Timer和Timetask，我们可以实现定时启动某个线程，在java.util 中</p>
<h3 id="quartz"><a href="#quartz" class="headerlink" title="quartz"></a>quartz</h3><h3 id="HappenBefore"><a href="#HappenBefore" class="headerlink" title="HappenBefore"></a>HappenBefore</h3><h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><p>保证线程间变量的可见性，线程对变量进行修改之后，要立刻回写到主存，线程对变量读取的时候，要从主内存中读，而不是缓存</p>
<h3 id="dcl单例模式"><a href="#dcl单例模式" class="headerlink" title="dcl单例模式"></a>dcl单例模式</h3><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><h3 id="CAS原子操作"><a href="#CAS原子操作" class="headerlink" title="CAS原子操作"></a>CAS原子操作</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
  </entry>
  <entry>
    <title>HTML&amp;CSS学习笔记</title>
    <url>/2020/03/21/HTML&amp;CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>写于1月18日至1月26日左右</p>
<h1 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h1><p>1.HTML中不区分大小写</p>
<p>2.注释不能嵌套</p>
<p>3.标签必须结构完整</p>
<p>4.XML 更加严谨</p>
<p>5.浏览器尽最大努力正确加些页面，自动修正，但有些情况会错误修正</p>
<p>6.HTML标签可以嵌套，但是不能交叉嵌套</p>
<p>7.使用内联框架<strong><em>iframe</em></strong>可以引入一个外部的页面  使用iftrame来创建一个内联框架 </p>
<p>现实开发中不推荐使用内联框架，内联框架中的内容不会被搜索引擎所检索</p>
<p><img src="../images/code.jpg" alt></p>
<a id="more"></a>

<p>8.超链接：从一个页面跳转到另一个见面 用标签a&lt;&gt;(a在&lt;&gt;中间）来创建一个超链接</p>
<p>属性： href：指向链接跳转的目标地址， 相对路径or完整地址</p>
<p>a标签中的target属性可以用来指定打开链接的位置 </p>
<ol>
<li>_self：默认值 在当前窗口打开</li>
<li>_blank:在一个新的窗口中打开链接</li>
</ol>
<p><strong><em>可以设置一个内联框架的name属性值，链接将会在指定的内联框架中打开</em></strong></p>
<p>用#代表空链接 默认为页面的顶部</p>
<p>HTML中有一个属性作为标签的唯一标识：id</p>
<p>9.center标签中的内容会默认在页面中居显示</p>
<p>10.发送电子邮件的超链接，自动打开计算机中默认的邮件客户端</p>
<p><a href="mailto:xxx@xxx.com">   联系我们  </a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">SRC属性:</span><br><span class="line">相对路径：</span><br><span class="line">返回路径：..&#x2F; 返回上一级目录  </span><br><span class="line">--&gt;</span><br><span class="line">&lt;!-- </span><br><span class="line">图片格式</span><br><span class="line">JPEG：多颜色，可以压缩，但是不支持透明 一般用来保存照片</span><br><span class="line">GIF： 支持的颜色较少，只支持简单透明，支持动态图</span><br><span class="line">PNG：支持的颜色多，支持复杂透明</span><br><span class="line">图片使用原则：</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>





<h1 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h1><p><strong>css笔记</strong></p>
<p>层叠样式表 <code>cascading style sheets</code></p>
<p>1.内联样式：样式直接编写到style属性元素中 只对当前元素中的内容起作用</p>
<p>2.也可以将css样式编写到head中的style标签里，将样式表编写的style标签中，通过css选择器选中指定的元素，为这些元素一起设置样式。也可以将表现和结构进一步分离（推荐使用） （少用标签选择器）</p>
<p>3.外部的css文件 .css 将样式表写到外部的css文件中，通过link标签将外部的cs文件引入到当前的页面当中 这样外部文件css样式表将会应用到当前页面中 </p>
<p>css样式统一写到尾部的样式表中，完全使结构和表现分离，可以使样式表在不同的页面表中使用，虽大限度使演示表复用</p>
<p>link标签引入可以利用浏览器的缓存，加快用户访问的速度提高，开发中推荐只用外部css文件（最不推荐内联样式）</p>
<p>4.style标签里不能用HTML注释 </p>
<p>/<em>css的注释，必须写在tyle标签中或者css文件中</em>/</p>
<p>css语法：选择器    声明块</p>
<p>选择器：选中页面中的指定元素，并且将声明块中的样式应用到选择器对应的元素上</p>
<p>声明块：紧跟在选择器后用{}，一组一组的名值对结构，一个声明块中有多个声明用；隔开</p>
<p>声明的样式名和样式值之间使用：来连接</p>
<p>5.块元素 <code>div</code>就是一个块元素，独占一行无论内容有多少 p h1 h2 h3…</p>
<p>div这个标签没有任何语义，纯粹的块元素，不会被里面的元素设置任何默认样式，主要用于给页面布局 </p>
<p>6.span 是一个内联元素（行内元素），只占自身大小的</p>
<p>常见内联元素： a img iframe span  </p>
<p>span 也没有任何语义，用来选中专门的文字，为文字来设置样式</p>
<p><strong><em>一般情况下只使用块元素去包含内联元素，而不会用内联包含块</em></strong></p>
<ul>
<li>a元素可以包含任意元素，除了它本身</li>
<li>p元素不可以包含任何块元素</li>
</ul>
<p>7.<strong><em>类选择器</em></strong>：通过元素的class属性选中一组元素 class在标签中</p>
<p>style中用 . +类名选中</p>
<p><strong><em>选择器分组</em></strong>：通过选择器同时选中多个选择器对应的元素</p>
<p>语法： 选择器1，选择器2，..{}</p>
<p><strong><em>通配选择器</em></strong> </p>
<p><strong><em>复合选择器</em></strong>    选择器1选择器2…{}</p>
<p>·#· id选择器      .(点)：类选择器</p>
<p>后代元素选择器： 祖先元素（空格）后代元素{}</p>
<p>子元素选择为其：父元素&gt; 子元素{}（IE6以下不支持子元素选择器）</p>
<p>8.伪类：专门用来表示元素的一种特殊的状态 比如：访问过的超链接，普通的超链接，获取焦点的文本框  ；当我们要为这些特殊状态元素设置样式时使用伪类</p>
<p>浏览器通过历史记录判定是否访问过，由于涉及用户隐私使用visited时只能设置字体颜色</p>
<p>正常链接 a<code>：link</code></p>
<p>访问过的连接a<code>：visited</code></p>
<p>鼠标滑过的连接 a<code>:hover</code>表示鼠标</p>
<p>超链接被点击 a<code>：active</code></p>
<p>获取焦点 -<code>：focus</code></p>
<p>指定元素前 -<code>:before</code></p>
<p>指定元素后 -：<code>after</code></p>
<p>选中的元素 -<code>::selection</code>（两个冒号 注意）</p>
<p>hover和active也可以给其他元素设置</p>
<p>9.伪元素：<code>first-letter first-line</code></p>
<p>通过css添加的字符无法选中</p>
<p>10.属性选择器：【属性名=属性值】</p>
<p> 使用[]  p[title]{} p[title=hello]{} </p>
<p>p[title^=”ab”]{} 属性名以ab开头</p>
<p>p[title$=”c”]{} 属性名以c为结尾</p>
<p>p[title*=”c”]{}属性名中包含c即可</p>
<p>title属性可以给任何标签指定</p>
<h1 id="day3"><a href="#day3" class="headerlink" title="day3"></a>day3</h1><p>1.子元素的伪类： p:first-child p为指定标签 若用*为所有标签</p>
<p>last-child nth-child(num):参数选择指定位置 even参数选择偶数 odd选择奇数</p>
<p>first-of-type last-of-type nth-of-type:type指的是当前类型的子元素的排列</p>
<p>2.兄弟元素选择器：  语法：前一个+后一个 选中一个元素后面紧挨着的指定的兄弟元素</p>
<p>前一个~后一个 选中后面所有的兄弟元素</p>
<p>3.否定伪类：从已选中的元素中剔除某些元素 not(.hello)</p>
<p>4.样式的继承 继承 透过 transparent</p>
<p>5.选择器的优先级：</p>
<ul>
<li>内联（行列）样式 优先级1000</li>
<li>id选择器：100</li>
<li>类和伪类：10</li>
<li>元素选择器：1</li>
<li>通配*，优先级0</li>
<li>继承的样式，没有优先级</li>
</ul>
<p><strong>* 选择器中包含多种选择器的时候要将多种选择器的优先级相加然后再比较*</strong></p>
<p>选择器优先级计算不会超过他的最大的数量级，如果优先级一样选择靠后的样式</p>
<p>样式的最后添加一个！important，该样式获得一个最高的优先级：<br><code>.p{
                background-color: greenyellow！important;
            }</code></p>
<p>6.伪类顺序 link visited hover active</p>
<h2 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h2><p>1.em和strong表示一个强调的内容 </p>
<p> em主要表示语气上的强调，浏览器中默认为斜体</p>
<p> strong表示强调的内容，语义更强烈，默认用粗体</p>
<p>单纯改变样式，和语义无关：i标签 斜体； b标签 加粗；</p>
<p>small cite（表示参考的内容） q标签：表示引用； blockquote：长引用（块级引用）</p>
<p>sup标签：上标   ； sub标签：下标</p>
<p>del标签：删除的内容； ins标签：下划线 ；pre标签：预格式标签，保留格式，不会忽略多个空格（无语义） ； code标签：语义标签表示代码，与pre一起使用</p>
<h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><ul>
<li>无序列表</li>
<li>有序列表</li>
<li>定义列表</li>
</ul>
<p>无序列表：ul创建无序列表，li在ul中创建一个一个的列表项 一个li就是一个列表项</p>
<p>通过ul中的type属性修改项目符号  disc; square; circle  ul，li都是块元素</p>
<p>修改默认样式，css的style标签中</p>
<p>有序列表；ol 使用有序的符号作为项目符号 type属性指定序号的类型</p>
<p>type可选：1，a/A, i/I 【可以有序列表无序列表互相嵌套】</p>
<p>定义列表：dl来创建，两个子标签<dt>:定义的内容<dd>对定义内容的描述</dd></dt></p>
<h2 id="文本格式"><a href="#文本格式" class="headerlink" title="文本格式"></a>文本格式</h2><p>1.1em=1font-size</p>
<p>2.rgb：0~255（，，） 或者使用16进制 #ffffff 两位重复的颜色，可以简写</p>
<p>3.字体：设置文字的大小，浏览器中默认16px，font-size并不是文字本身的大小，是格的高度，用font-family指定文字的字体，如果浏览器不支持仍使用默认，使用多个字体浏览器优先使用前面的字体，如果前面的没有再尝试下一个</p>
<p>serif：衬线字体</p>
<p>sans-serif：非衬线字体</p>
<p>monospace：等宽字体</p>
<p>cursive：草书字体</p>
<p>fantasy：虚幻字体</p>
<p>4.CSS中通过行高来设置行距： line-height:40px（80%或者是百分数；或者是一个数值，字体大小的相应倍数） 与font-size一起使用</p>
<p>font：A px/B px 字体大小/行高</p>
<ol start="5">
<li><ul>
<li>text-transform设置文本的大小写</li>
<li>text-decoration添加文本的修饰【超链接会默认添加下划线】</li>
<li>letter-spacing：字间距 ；word-spacing 单词之间的间距</li>
<li>text-align：文本对齐方式  left right center justufy(两端对齐)</li>
<li>text-indent：设置首行缩进 一般以em作为单位</li>
</ul>
</li>
</ol>
<h2 id="盒子模型box"><a href="#盒子模型box" class="headerlink" title="盒子模型box"></a>盒子模型box</h2><p>1.内容区 内边距(padding)  边框 (border) 外边距(margin)</p>
<p>2.垂直相邻外边距发生重叠，兄弟元素之间的相邻外边距取最大值而不是求和</p>
<p>如果父子元素垂直外边距相邻，子元素的外边距会设置给父元素</p>
<p>两种处理方法</p>
<p>3.通过display样式改变元素的类型  </p>
<p>inline：将一个元素作为内联元素显示</p>
<p>block：将一个元素设置为块元素显示</p>
<p>inline-block：转换为行内块元素 可以设置宽高又独占一行</p>
<p>visibility： visible默认 hidden 元素不会显示但仍占据位置</p>
<p>4.overflow 属性：可选 visible hidden scroll  auto</p>
<h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><p>文档流在网页的最顶层，表示的页面中的位置，创建的元素默认在文档流中</p>
<p>文档在文档流中的特点</p>
<ul>
<li>块元素：独占一行，自上向下【默认宽度 默认高度】</li>
<li>内联元素：只占自身大小，默认从左向右排列【宽度 高度】</li>
</ul>
<p>inline-block</p>
<p>1.float属性使元素浮动，脱离文档流：可选 none left right</p>
<h1 id="day5"><a href="#day5" class="headerlink" title="day5"></a>day5</h1><p>1.高度塌陷（没有深入了解）</p>
<p>2.导航条设计</p>
<p>3.PS的简单认识</p>
<p>4.div.box$*3 建立三个div元素 box123</p>
<p>5.相对定位 绝对定位 固定定位 元素的position属性</p>
<p>6.开启定位的元素使用z-index修改元素的层级</p>
<p>7.opacity可以用来设置元素背景的透明 需要一个0-1之间的值 0表示完全看不见 1完全不透明 opacity在IE8及以下不支持 需要使用filter属性 alpha（opacity=50）</p>
<p>8.设置背景图片 background-img=url（相对路径）</p>
<p>background-repeat属性 repeat no-repeat repeat-x repeat-y 设置背景图片是否重复</p>
<p>背景图片默认贴着页面左上角显示 background-position属性调整:top left right bottom center 或者直接指定偏移量 -px -px 第一个是水平偏移第二个是垂直</p>
<p>background-attachment属性设置背景是否固定 fixed scroll </p>
<p>background简写属性 不写表示默认属性</p>
<p>9.图片整合技术：多个图片整合成一个图片同时加载，解决闪烁问题</p>
<h1 id="day6"><a href="#day6" class="headerlink" title="day6"></a>day6</h1><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>1.table 标签 使用tr表示表格的一行 td创建一个单元格</p>
<p>table是一个块元素</p>
<p>2.colspan横向的合并单元格 <td colspan="2">D3</td></p>
<p>   rowspan纵向合并单元格</p>
<p>3.table的属性 width margin border border-spacing border-collapse</p>
<p>设置的合并后border-spacing自动失效</p>
<p>4,th</p>
<p>5.长表格 ： 表头 表格的主体 表格底部 都是table的子标签</p>
<p>​     <thead> <tbody> <tfoot> 需要直接写到table中，tr写在这些标签中</tfoot></tbody></thead></p>
<p>如果没有tbody，浏览器自动添加tbody并把tr放在其中</p>
<p>6.完善clearfix</p>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>1.网页中个人信息通过表单提交给服务器 比如搜索框</p>
<p>2.使用form 标签创建一个表单 必须指定一个action属性，指向一个服务器</p>
<p>提交表单时会提交到action属性对应的地址</p>
<form action="target.html"> </form>
3.使用input创建一文本框，type属性是text，如果希望表单中的数据提交到服务器中，还必须给表单提供一个那么属性，name表示提交内容的名字 

<p>用户填写的信息会附在url地址的后边以查询字符串的形式发送给服务器</p>
<p>url地址？查询字符串</p>
<p>格式： 属性名=属性值</p>
<p>4.密码框 不能用type的text属性，明文    修改为type=“password”</p>
<p>5.单选按钮 type属性：radio  name属性相同的是同一组按钮 使用label标签可以选中文字</p>
<p>value属性必须设置</p>
<p>6.多选框 type属性CheckBox</p>
<p>7.下拉列表 使用select标签 option作为子标签 </p>
<p>如果希望在单选按钮或者是多选框中指定默认选中的选项，可以在希望选中的选项中添加checked=“checked”属性 selected=“selected”</p>
<p>select添加一个multiple=“multiple”，下拉列表变为一个多选的下拉列表</p>
<p>创建optgroup分组 添加label标签进行分组</p>
<p>8.type=“reset” 创建重置按钮 ，点击后表单内容恢复为默认值 </p>
<p>9.除了使用input 也可以使用button标签来创建按钮（成对出现，可以插入图片）</p>
<p>10.在表单中使用fieldset为表单项进行分组，将表单项中的同一组放到一个fieldset中，在fieldset中使用legend子标签，来指定组名</p>
<h2 id="框架集"><a href="#框架集" class="headerlink" title="框架集"></a>框架集</h2><p>框架集与内联框架的作用相似，都是用在一个页面中引入其他的外部页面，框架集可以引用多个页面，内联框架只能引入一个，h5标准中，推荐使用框架集</p>
<p>使用frameset来创建一个框架集，<strong><em>注意frameset和body不能出现在同一个页面中</em></strong></p>
<p>frameset中使用frame子标签来指定要引入的页面</p>
<p>属性：rows cols 指定框架集中的页面的排列，这两个属性frameset必须指定一个</p>
<p>frameset中也能嵌套frameset</p>
<p><strong><em>frameset和iframe一样，里面的内容都不会被搜索引擎检索。</em></strong></p>
<p><strong><em>使用框架集意味着网页中不能有自己的内容，只能引入其他的页面，每单独加载一个界面，浏览器都需要重新发送一次请求，引入几个界面就要发送几次请求</em></strong></p>
<h2 id="Hack-解决兼容性"><a href="#Hack-解决兼容性" class="headerlink" title="Hack 解决兼容性"></a>Hack 解决兼容性</h2><h3 id="CSS参考手册"><a href="#CSS参考手册" class="headerlink" title="CSS参考手册"></a>CSS参考手册</h3><p>CSS Hack不到万不得已的情况尽量不要使用</p>
<p>Hack有风险，使用需谨慎</p>
<p>1.条件Hack</p>
<p>&lt;IE6中png的修复&gt;</p>
<p>使用JavaScript来解决该问题，向页面中引入一个外部的JavaScript文件</p>
<p>CSS Hack实际上指一个特殊代码，这段代码只在特殊的浏览器中执行，而其他浏览器不能识别</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if IE 6]</span></span><br><span class="line"><span class="comment"> &lt;p&gt;为了您和家人的健康，请远离IE6！！&gt;</span></span><br><span class="line"><span class="comment">&lt;/p&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.属性Hack</p>
<h1 id><a href="#" class="headerlink" title></a></h1><p>后记：MarkDown的精髓还没有仔细体会，仍在学习中。当前水平大体是将他作为普通文本格式的替代品，敬请谅解。</p>
<p>联系方式：<a href="mailto:213181848@seu.edu.cn">213181848@seu.edu.cn</a> </p>
]]></content>
  </entry>
  <entry>
    <title>陈烨的 2019年度总结</title>
    <url>/2020/03/21/%E9%99%88%E7%83%A8%E7%9A%84%202019%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="陈烨的-2019年度总结"><a href="#陈烨的-2019年度总结" class="headerlink" title="陈烨的 2019年度总结"></a><strong>陈烨的</strong> 2019年度总结</h2><h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a><strong>回顾</strong></h4><p>2015 2016 2017 2018 2019，每年的年度总结都不曾落下，写在日记里。</p>
<p>之前的文字现在看起来不如当时那般融入了情感，只能略微地回忆起当时的心情。</p>
<p>2015年12月31日，“月考失利，这样的成绩令人无地自容。”</p>
<p>2016年12月31日，“和几乎每一次放假一样，一到家就是鸡飞狗跳。”“然而仿佛一年过去了，我仍不曾真实地记录下每一点想法。”“眨眼，我的笔就跨过了三个年头。”“那么眨眼间，下一幕又是什么呢？”</p>
<p>2017年12月31日，衡水，昆仑大酒店。“爸爸和学校的老师前几日来过了。””我选择了隐忍，是为了图强。”“我的高考，妹妹的诞生。”</p>
<p>2018年12月31日，南京，“到了大学，反倒写日记的时间少了。”“一个人来到这个学校，每一天都值得铭记。”2019年1月1日。“想在跨年晚会前把日记写完，但高估了思维转化为文字落在纸面上的时间了。”“放手去追求，放手爱自由。”“ ”即使倒下，也要朝着未名湖的方向” 。”“已经走远了，也许会回来，也许不会。我不想停留在这种记忆里了。”“2019，向往自由。”</p>
<p>2019年12月31日，说来就来了。</p>
<p>（未完）</p>
<p> <img src="../images/naruto.jpg" alt></p>
<a id="more"></a>

<h4 id="2019"><a href="#2019" class="headerlink" title="-2019"></a><strong>-2019</strong></h4><p>其实可以很好地从时间线上回忆，因为“摇摆依旧”跨年演唱会就在前天。之所以这么说是因为昨天是”廿廿不忘”。</p>
<p>并不是所有的念念不忘都有回响的，可是更多的是种寄托。今年的日记只有八页，仔细翻阅也并无记载太多的东西，值得一提的是有段时间开了一个叫做“ cybryant ”的小屋”的公众号，把日记试的文章写在那里，大概也有八九篇罢。后来因为社会实践停运了，再后来也无暇去打理，也就没有重新建立的打算。</p>
<p>19年的伊始，经历了第一个考试周，那时候保持着十二点睡觉八点钟起床的考试周专属作息，却日复一日地饱受作息不统一的室友带来的的烦恼。考罢倒也平平淡淡的，想来大学的第一个寒假没有做什么事情，有的同学趁此学完了雅思托福，或者是去日本游玩，或者是静下心来学点什么。我没有，单纯地只是和家人在一起，带小孩，看着妹妹一天天地长大（那时候她还是一个彻彻底底的婴儿），更多的时间还是同家里的兄弟们出去玩耍，日常地九十点钟回家，街上都没有什么人了，自然是十分开心的。还认识了马燕儿，一个十分开朗的小姑娘。其实寒假不做点什么，实在是血亏一笔。</p>
<p>返校后就开始一到十六周的计数了，清楚记得前四周没有C++课程，倒也不算十分忙碌。同样十分悠闲的刘超颖造访南京，恐怕是整个三月份最愉快的事情，我们去了玄武湖，去了五台山的先锋书店，去了钟山，总之这次出游十分惬意，也算是给机械运转一般的生活增添了一些焠出的火花。后来这个学期刘超颖给我写过几封信，都用的是平邮，贼慢，每次她告诉我寄信了然后我就盼着能在围合大厅的信报栏上看到我的名字，生活就多了一些期盼。那个时候觉得宣城和南京更近一些就好了，也有过去一次宣城的想法，后来这种想法就消失了。</p>
<p>这个学期在忙些什么我倒有个数。科协新媒的活我大都是划水过了，似乎副部长也看出了我的想法，也并没有过多的说什么，我想所具有的责任感与此并不冲突。那个时候忙着学院院运会的事情，前前后后地应该是好几周，包括校运会。同体育部在一起是我喜欢的，我选择的是我热爱的，其实热爱所选择的这一说法略微有一些牵强附会。后来我毫不犹豫地竞选了体育部部长，也是选择了我所热爱的。很幸运遇到了许朝阳这样的好学长，自然而然地称兄道弟，交流了很多想法，尤其是在网安这样没有16级的学院，学长的经验尤为重要。他同我讲了一些未来的规划的建议，有时也彻夜聊聊感情，也不知道有啥好聊的哈哈。当然赵笛言也很棒，很高兴能够遇到这样的学姐。最后忙碌的是暑假的社会实践了，从立项申请到答辩再到后面的组织以及出发，说是19年最令人操心的恐怕就是这个事情。坐在前往南昌的高铁上还没有确定好行程，中间强行改了两次，前往山里的井冈山下七乡，磕磕绊绊总算是把社会实践给完成了。这一次经理让我意识到作为组长要统筹兼顾到很多东西，有时候决策的失误是允许被原谅的。当时我提出了一个系统与接口的理论，每一个组员都是一个部件，一个接口，他们需要的只是完成系统分派的任务，然后并不十分清楚其他接口正在做的事情，担任这个系统的就是组长，必须根据每一个部件的能力，特点，目前手头已经接收的任务进行分配。这不是P2P，系统保证每一接口都在高效运作整体理应是高效的。当然少不了矛盾的存在。在社会实践期间，文俊给了我许多帮助。暑假里他去美国了，如我所想回来讲述了一些十分有趣的故事。</p>
<p>期间端午节去了一次上海，刚好在高考那两天，写了一篇很长的文字来缅怀一下自己的高三。似乎暑假里也没有做什么有意义的事情，想学一些东西最后也没有学通到能直接用上，也不过是陪陪妹妹，打打游戏，跟朋友玩之类的。暑假里为了社会实践也占去了很多时间。</p>
<p>东大的返校全国再找不到更早的，回学校开始了短学期，对新西兰大学的外教Lee印象很深，反倒是对MFC怎么写忘得一干二净。这么说着说着，也就到了本学期的事情了。把其他任何事情都推了，单单留下一个体育部部长，说来闲云野鹤似的，其实并不。有时候想我是不是管的太多，搞得太复杂，无论是否是这样，这个学期已经是过去了。我逐渐明白一个道理，我喜欢的是这个事情本身，这不过是我喜欢的事情之一，而已。</p>
<p>九月中秋我去了杭州一次，一半陪家人，一半找朋友。在西湖白堤上看中秋的满月别有风趣。书瑜哥哥也会和我讲很多，走的时候叔叔给了一笔钱让我拿去玩耍，这也太棒了。九月底罗宇坤来过南京一次。十月，国庆节，小峰来南京，和king黄一起去游乐园玩儿，高中一起的伙伴在异乡相聚还挺有一些触动的，三个人住在南京的乡下挤在大床上聊到很晚。近来都十分平淡，除了连续几天在机电平台调试小车最后还拉胯让我着实暴躁了一回。有种感觉，莫名地到了学期末，总觉得忙完这件事就好了忙完那件事就好了，可是这种事情一件又一件地来像流水一样，无暇顾及其他。然后，就年底了。</p>
<h4 id="跨年"><a href="#跨年" class="headerlink" title="跨年"></a><strong>跨年</strong></h4><p>跨年前的日子我不知如何用一个恰当的词语来形容，踌躇了好久，终于鼓起勇气问张湄婧要不要一起去看跨年演唱会……后来跟大伙去景枫来回以及等待的时间远超了预期，结果就错过了…现在回想起，应该是2019年最后一个遗憾吧。</p>
<p>这也大概是我2020年伊始的最大动力。</p>
<p>最终跨年找到了刘新元，错综交集的老友，他讲了一些心里一直想说的话，最后我们一起看了一会儿演唱会，就跟365天前一样，一起倒计时，只不过这次迎来的是2020.</p>
<p>零点的时候和几个朋友互相打电话祝福，算是跨年的传统。</p>
<h4 id="2020"><a href="#2020" class="headerlink" title="2020-"></a><strong>2020-</strong></h4><p>2020年余额100%，空白交给我填补。</p>
<p>留下遗憾是必然的，只不过希望自己大胆地去追寻。Flag慢慢竖起来，倒下无所谓。</p>
<p>我希望在2020年把人生的里程碑一个一个拿下，去尝试去摸索去拥抱。</p>
<p>2019的词语是自由，2020的词语是探索。</p>
<p>很套路的结尾：你好，2020.</p>
<p>写于2020年1月1日</p>
]]></content>
  </entry>
  <entry>
    <title>Welcome to my World</title>
    <url>/2020/03/21/hello-world/</url>
    <content><![CDATA[<p>你好你好！</p>
<p>这是我第一次动手搭建自己的博客，希望能在这里把一些有趣的事情分享给大家。有的人可能觉得，程序员应该写技术博客呀，但是程序员也是有感情的，还有的程序员喜欢看书喜欢拉小提琴（虽然很久不练习了），也喜欢听音乐看电影之类的，并且很乐于把他们分享给大家。总之，我的地盘我做主，welcome to my world !</p>
<p><img src="/21/hello-world/sakura.jpg" alt></p>
<p><img src="../images/sakura.jpg" alt></p>
<a id="more"></a>



]]></content>
  </entry>
</search>
